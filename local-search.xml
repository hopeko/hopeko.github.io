<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>async、await的线程(上下文)逻辑</title>
    <link href="/2020/10/02/async%E5%92%8Cawait%E7%9A%84%E7%BA%BF%E7%A8%8B(%E4%B8%8A%E4%B8%8B%E6%96%87)%E9%80%BB%E8%BE%91/"/>
    <url>/2020/10/02/async%E5%92%8Cawait%E7%9A%84%E7%BA%BF%E7%A8%8B(%E4%B8%8A%E4%B8%8B%E6%96%87)%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<h2 id="UI程序的上下文"><a href="#UI程序的上下文" class="headerlink" title="UI程序的上下文"></a>UI程序的上下文</h2><p><font size=2 color=gray>当一个方法被关键字<code>async</code>声明时，意味着该方法可异步执行，同时激活方法内的<code>await</code>关键字。</font> </p><p>UI程序中只允许唯一的一个拥有UI上下文（SynchronizationContext）的线程运行。</p><p>例1</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><span class="hljs-function"></span>&#123;    Console.WriteLine(<span class="hljs-string">$&quot;Before WaitAsync =&gt; Thread Id: <span class="hljs-subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);    <span class="hljs-keyword">await</span> WaitAsync();    Console.WriteLine(<span class="hljs-string">$&quot;After WaitAsync =&gt; Thread Id: <span class="hljs-subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);    <span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WaitAsync</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>    &#123;        Console.WriteLine(<span class="hljs-string">$&quot;Before Task.Run =&gt; Thread Id: <span class="hljs-subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);        <span class="hljs-keyword">await</span> Task.Run(() =&gt; &#123;            Console.WriteLine(<span class="hljs-string">$&quot;await =&gt; Thread Id: <span class="hljs-subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);        &#125;);        Console.WriteLine(<span class="hljs-string">$&quot;After Task.Run =&gt; Thread Id: <span class="hljs-subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);    &#125;&#125;<span class="hljs-comment">//点击按钮，输出</span><span class="hljs-comment">//Before WaitAsync =&gt; Thread Id: 1</span><span class="hljs-comment">//Before Task.Run =&gt; Thread Id: 1</span><span class="hljs-comment">//await =&gt; Thread Id: 3</span><span class="hljs-comment">//After Task.Run =&gt; Thread Id: 1</span><span class="hljs-comment">//After WaitAsync =&gt; Thread Id: 1</span></code></pre></div><p>可以看到，除了WaitAsync里的await语句在另一线程执行，await前后的代码均在原线程，也就是UI线程执行。</p><p>接下来将<code>await WaitAsync()</code>改为<code>WaitAsync().Wait()</code>再执行</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">//点击按钮，输出</span><span class="hljs-comment">//Before WaitAsync =&gt; Thread Id: 1</span><span class="hljs-comment">//Before Task.Run =&gt; Thread Id: 1</span><span class="hljs-comment">//await =&gt; Thread Id: 3</span></code></pre></div><p>此时，程序将一直阻塞在await语句，原因是当使用<code>Task.Wait()</code> <code>Result</code> <code>GetAwaiter()</code> <code>GetResult()</code>等去获取结果时，<code>await</code>将阻塞当前线程，而当<code>await</code>内代码执行完后，<code>await</code>尝试恢复上下文，此时UI线程被阻塞，必须等<code>await</code>语句结束才能继续执行，因而造成死锁。</p><p>再将await语句改为</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">await</span> Task.Run(() =&gt; &#123;    Console.WriteLine(<span class="hljs-string">$&quot;await =&gt; Thread Id: <span class="hljs-subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);&#125;).ConfigureAwait(<span class="hljs-literal">false</span>);<span class="hljs-comment">//点击按钮，输出</span><span class="hljs-comment">//Before WaitAsync =&gt; Thread Id: 1</span><span class="hljs-comment">//Before Task.Run =&gt; Thread Id: 1</span><span class="hljs-comment">//await =&gt; Thread Id: 3</span><span class="hljs-comment">//After Task.Run =&gt; Thread Id: 3</span><span class="hljs-comment">//After WaitAsync =&gt; Thread Id: 1</span></code></pre></div><p><code>ConfigureAwait(false)</code>给Task配置了一个标记，使得在await内部代码执行结束后忽略之前的上下文，直接用当前线程执行async里await下面的代码，因而不会造成死锁。所以，精通异步编程的大佬有句话，“一旦开始使用async，最好全程使用它”。</p><p>接下来把代码恢复到最开始的版本，再将await语句改为</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">await</span> Task.Run(() =&gt; &#123;    Console.WriteLine(<span class="hljs-string">$&quot;await =&gt; Thread Id: <span class="hljs-subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);&#125;).ContinueWith((task) =&gt; &#123;    Console.WriteLine(<span class="hljs-string">$&quot;ContinueWith =&gt; Thread Id: <span class="hljs-subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);&#125;);<span class="hljs-comment">//多次点击按钮，输出</span><span class="hljs-comment">//1</span><span class="hljs-comment">//Before WaitAsync =&gt; Thread Id: 1</span><span class="hljs-comment">//Before Task.Run =&gt; Thread Id: 1</span><span class="hljs-comment">//await =&gt; Thread Id: 3</span><span class="hljs-comment">//ContinueWith =&gt; Thread Id: 4</span><span class="hljs-comment">//After Task.Run =&gt; Thread Id: 1</span><span class="hljs-comment">//After WaitAsync =&gt; Thread Id: 1</span><span class="hljs-comment">//2</span><span class="hljs-comment">//Before WaitAsync =&gt; Thread Id: 1</span><span class="hljs-comment">//Before Task.Run =&gt; Thread Id: 1</span><span class="hljs-comment">//await =&gt; Thread Id: 3</span><span class="hljs-comment">//ContinueWith =&gt; Thread Id: 3</span><span class="hljs-comment">//After Task.Run =&gt; Thread Id: 1</span><span class="hljs-comment">//After WaitAsync =&gt; Thread Id: 1</span><span class="hljs-comment">//3</span><span class="hljs-comment">//Before WaitAsync =&gt; Thread Id: 1</span><span class="hljs-comment">//Before Task.Run =&gt; Thread Id: 1</span><span class="hljs-comment">//await =&gt; Thread Id: 5</span><span class="hljs-comment">//ContinueWith =&gt; Thread Id: 5</span><span class="hljs-comment">//After Task.Run =&gt; Thread Id: 1</span><span class="hljs-comment">//After WaitAsync =&gt; Thread Id: 1</span><span class="hljs-comment">//...</span></code></pre></div><p>多次测试说明，<code>ContinueWith</code>里的代码并不一定由执行await的线程执行，具体由哪一个线程执行在于<code>TaskScheduler</code>的调度。</p><h2 id="ASP-NET-Classic中的上下文"><a href="#ASP-NET-Classic中的上下文" class="headerlink" title="ASP.NET Classic中的上下文"></a>ASP.NET Classic中的上下文</h2><p>ASP.NET Classic程序（ASP.NET Core以前）使用的ASP.NET请求上下文跟UI程序的上下文不同，但结果实际上是类似的。</p><div class="code-wrapper"><pre><code class="hljs csharp">Debug.WriteLine(<span class="hljs-string">$&quot;Before WaitAsync =&gt; Thread Id: <span class="hljs-subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);<span class="hljs-keyword">await</span> WaitAsync();Debug.WriteLine(<span class="hljs-string">$&quot;After WaitAsync =&gt; Thread Id: <span class="hljs-subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WaitAsync</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;    Debug.WriteLine(<span class="hljs-string">$&quot;Before Task.Run =&gt; Thread Id: <span class="hljs-subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);    <span class="hljs-keyword">await</span> Task.Run(() =&gt; &#123;        Debug.WriteLine(<span class="hljs-string">$&quot;await =&gt; Thread Id: <span class="hljs-subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);    &#125;);    Debug.WriteLine(<span class="hljs-string">$&quot;After Task.Run =&gt; Thread Id: <span class="hljs-subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);&#125;<span class="hljs-comment">//输出</span><span class="hljs-comment">//1</span><span class="hljs-comment">//Before WaitAsync =&gt; Thread Id: 7</span><span class="hljs-comment">//Before Task.Run =&gt; Thread Id: 7</span><span class="hljs-comment">//await =&gt; Thread Id: 6</span><span class="hljs-comment">//After Task.Run =&gt; Thread Id: 7</span><span class="hljs-comment">//After WaitAsync =&gt; Thread Id: 7</span><span class="hljs-comment">//2</span><span class="hljs-comment">//Before WaitAsync =&gt; Thread Id: 6</span><span class="hljs-comment">//Before Task.Run =&gt; Thread Id: 6</span><span class="hljs-comment">//await =&gt; Thread Id: 7</span><span class="hljs-comment">//After Task.Run =&gt; Thread Id: 7</span><span class="hljs-comment">//After WaitAsync =&gt; Thread Id: 7</span><span class="hljs-comment">//3</span><span class="hljs-comment">//Before WaitAsync =&gt; Thread Id: 9</span><span class="hljs-comment">//Before Task.Run =&gt; Thread Id: 9</span><span class="hljs-comment">//await =&gt; Thread Id: 14</span><span class="hljs-comment">//After Task.Run =&gt; Thread Id: 15</span><span class="hljs-comment">//After WaitAsync =&gt; Thread Id: 15</span></code></pre></div><p>虽然ASP.NET在await之后使用的是线程池里的线程去恢复ASP.NET请求上下文，但该请求上下文依然不能被超过一个线程同时拥有。所以，如果将<code>await WaitAsync()</code>改为<code>WaitAsync().Wait()</code>，执行</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">// 结果</span><span class="hljs-comment">//Before WaitAsync =&gt; Thread Id: 6</span><span class="hljs-comment">//Before Task.Run =&gt; Thread Id: 6</span><span class="hljs-comment">//await =&gt; Thread Id: 7</span><span class="hljs-comment">//Before WaitAsync =&gt; Thread Id: 7</span><span class="hljs-comment">//Before Task.Run =&gt; Thread Id: 7</span><span class="hljs-comment">//await =&gt; Thread Id: 8</span><span class="hljs-comment">//Before WaitAsync =&gt; Thread Id: 8</span><span class="hljs-comment">//Before Task.Run =&gt; Thread Id: 8</span><span class="hljs-comment">//await =&gt; Thread Id: 9</span><span class="hljs-comment">//Before WaitAsync =&gt; Thread Id: 10</span><span class="hljs-comment">//Before Task.Run =&gt; Thread Id: 10</span><span class="hljs-comment">//await =&gt; Thread Id: 9</span><span class="hljs-comment">//Before WaitAsync =&gt; Thread Id: 11</span><span class="hljs-comment">//Before Task.Run =&gt; Thread Id: 11</span><span class="hljs-comment">//await =&gt; Thread Id: 9</span><span class="hljs-comment">//Before WaitAsync =&gt; Thread Id: 9</span><span class="hljs-comment">//Before Task.Run =&gt; Thread Id: 9</span><span class="hljs-comment">//await =&gt; Thread Id: 12</span><span class="hljs-comment">//Before WaitAsync =&gt; Thread Id: 12</span><span class="hljs-comment">//Before Task.Run =&gt; Thread Id: 12</span><span class="hljs-comment">//await =&gt; Thread Id: 13</span><span class="hljs-comment">//...</span></code></pre></div><p>同样会造成原线程的阻塞（估计会造成内存泄漏），但不会造成整个ASP.NET应用的阻塞，应用会用线程池里的其他线程去响应接下来的请求。也就是说ASP.NET Classic应用会在await内部代码执行完成时，尝试用线程池内的线程（可能是await前的线程，也可能不是）去恢复上下文。</p><p>如果用<code>ConfigureAwait(false)</code>进行配置则不会去恢复请求上下文。</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">//结果</span><span class="hljs-comment">//1</span><span class="hljs-comment">//Before WaitAsync =&gt; Thread Id: 6</span><span class="hljs-comment">//Before Task.Run =&gt; Thread Id: 6</span><span class="hljs-comment">//await =&gt; Thread Id: 7</span><span class="hljs-comment">//After Task.Run =&gt; Thread Id: 7</span><span class="hljs-comment">//After WaitAsync =&gt; Thread Id: 6</span><span class="hljs-comment">//2</span><span class="hljs-comment">//Before WaitAsync =&gt; Thread Id: 8</span><span class="hljs-comment">//Before Task.Run =&gt; Thread Id: 8</span><span class="hljs-comment">//await =&gt; Thread Id: 6</span><span class="hljs-comment">//After Task.Run =&gt; Thread Id: 6</span><span class="hljs-comment">//After WaitAsync =&gt; Thread Id: 8</span><span class="hljs-comment">//3</span><span class="hljs-comment">//Before WaitAsync =&gt; Thread Id: 6</span><span class="hljs-comment">//Before Task.Run =&gt; Thread Id: 6</span><span class="hljs-comment">//await =&gt; Thread Id: 7</span><span class="hljs-comment">//After Task.Run =&gt; Thread Id: 7</span><span class="hljs-comment">//After WaitAsync =&gt; Thread Id: 6</span></code></pre></div><h2 id="ASP-NET-Core应用和控制台程序"><a href="#ASP-NET-Core应用和控制台程序" class="headerlink" title="ASP.NET Core应用和控制台程序"></a>ASP.NET Core应用和控制台程序</h2><p>由于ASP.NET Core使用的是线程池上下文，该上下文由线程池内所有线程共享，所以不存在上述死锁或阻塞问题。同样地，控制台也不会出现类似的问题。</p>]]></content>
    
    
    <categories>
      
      <category>.Net</category>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>异步编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【源码】浅析Dictionary(System.Private.CoreLib)源码</title>
    <link href="/2020/09/15/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91%E6%B5%85%E6%9E%90Dictionary(System.Private.CoreLib)%E6%BA%90%E7%A0%81/"/>
    <url>/2020/09/15/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91%E6%B5%85%E6%9E%90Dictionary(System.Private.CoreLib)%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p><strong>注：本文参考的源码来自System.Private.CoreLib.dll，会有部分代码逻辑不同于.Net Framework的Dictionary。如需了解可参考本博客另一篇介绍</strong><a href="../../../../2020/08/30/【源码】浅看Dictionary(mscorlib)源码/">【源码】浅看Dictionary(mscorlib)源码</a></p><p><span style='font-size=2;font-style:italic;font-weight:bold;color:gray'>.Net Core的 Dictionary的实现使用了大量的 <span style="color:#f95288">ref</span>，目的都是为了用直接寻址替代间接寻址来提高性能</span></p><p>在自定义类重写<code>Equals()</code>和<code>GetHashCode()</code>的时候有些好奇，所以想看看Dictionary查找Key和存储键值对的原理。</p><p>下面通过看看几个最常用的Dictionary的方法，了解一下Dictionary的实现原理。</p><h2 id="GetHashCode"><a href="#GetHashCode" class="headerlink" title="GetHashCode"></a>GetHashCode</h2><p>首先看看如果在重写<code>Equals()</code>的时候不重写<code>GetHashCode()</code>会出现什么情况</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span></span><span class="hljs-class"></span>&#123;    public string Name;    public string Birth;    public bool Equals(Cat cat)    &#123;        <span class="hljs-keyword">if</span> (cat is <span class="hljs-literal">null</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        Console.WriteLine(<span class="hljs-string">&quot;自定义_Cat&quot;</span>);        <span class="hljs-keyword">return</span> Name == cat.Name &amp;&amp; Birth == cat.Birth;    &#125;    public override bool Equals(object obj) =&gt; Equals(obj <span class="hljs-keyword">as</span> Cat);&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> Main(string[] args)&#123;    Dictionary&lt;Cat, string&gt; cats = <span class="hljs-keyword">new</span> Dictionary&lt;Cat, string&gt;()    &#123;        &#123; <span class="hljs-keyword">new</span> Cat &#123; Name=<span class="hljs-string">&quot;小黑&quot;</span>, Birth = <span class="hljs-string">&quot;2020-2-1&quot;</span> &#125;, <span class="hljs-string">&quot;小黑&quot;</span> &#125;,        &#123; <span class="hljs-keyword">new</span> Cat &#123; Name=<span class="hljs-string">&quot;小黄&quot;</span>, Birth = <span class="hljs-string">&quot;2020-4-1&quot;</span> &#125;, <span class="hljs-string">&quot;小黄&quot;</span> &#125;,        &#123; <span class="hljs-keyword">new</span> Cat &#123; Name=<span class="hljs-string">&quot;憨豆&quot;</span>, Birth = <span class="hljs-string">&quot;2020-5-1&quot;</span> &#125;, <span class="hljs-string">&quot;憨豆&quot;</span> &#125;,        &#123; <span class="hljs-keyword">new</span> Cat &#123; Name=<span class="hljs-string">&quot;小黑&quot;</span>, Birth = <span class="hljs-string">&quot;2020-2-1&quot;</span> &#125;, <span class="hljs-string">&quot;小黑2&quot;</span> &#125;,    &#125;;    <span class="hljs-keyword">var</span> xiaohei = <span class="hljs-keyword">new</span> Cat &#123; Name = <span class="hljs-string">&quot;小黑&quot;</span>, Birth = <span class="hljs-string">&quot;2020-2-1&quot;</span> &#125;;    Console.WriteLine(cats.ContainsKey(xiaohei));&#125;<span class="hljs-comment">// 输出</span><span class="hljs-comment">// False</span></code></pre></div><p>可以看到虽然有两个“一样”的Key，<code>&#123; new Cat &#123; Name=&quot;小黑&quot;, Birth = &quot;2020-2-1&quot; &#125;, &quot;小黑&quot; &#125;</code>和<code>&#123; new Cat &#123; Name=&quot;小黑&quot;, Birth = &quot;2020-2-1&quot; &#125;, &quot;小黑2&quot; &#125;</code>，但是Dictionary还是正常初始化了，而在ContainsKey()时找不到Key。</p><h2 id="ContainsKey"><a href="#ContainsKey" class="headerlink" title="ContainsKey"></a>ContainsKey</h2><p>源码中的ContainsKey()直接return<code>!Unsafe.IsNullRef(ref FindValue(key));</code>，再看看FindValue(TKey key)的实现</p><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">ref</span> TValue <span class="hljs-title">FindValue</span>(<span class="hljs-params">TKey key</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)    &#123;        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);    &#125;    <span class="hljs-keyword">ref</span> Entry entry = <span class="hljs-keyword">ref</span> Unsafe.NullRef&lt;Entry&gt;();    <span class="hljs-keyword">if</span> (_buckets != <span class="hljs-literal">null</span>)    &#123;        Debug.Assert(_entries != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;expected entries to be != null&quot;</span>);        IEqualityComparer&lt;TKey&gt;? comparer = _comparer;        <span class="hljs-comment">// 下面的几个if else只是针对TKey类型的不同（或者有无传递comparer参数）而使用对应的EqualityComparer&lt;TValue&gt;去做比较，代码逻辑完全一样，所以这里只讲其中的一种情况。</span>        <span class="hljs-keyword">if</span> (comparer == <span class="hljs-literal">null</span>)        &#123;<span class="hljs-comment">// 根据构造函数逻辑，如果Tkey不是string类型，且未传递comparer参数（或传递的comparer为EqualityComparer&lt;TKey&gt;.Default），则_comparer为null，而使用EqualityComparer&lt;TKey&gt;.Default</span>            uint hashCode = (uint)key.GetHashCode();            <span class="hljs-built_in">int</span> i = GetBucket(hashCode);<span class="hljs-comment">// 取模获取_buckets的对应下标</span>            Entry[]? entries = _entries;            uint collisionCount = <span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(TKey).IsValueType)            &#123;<span class="hljs-comment">// TKey为值类型</span>                <span class="hljs-comment">// ValueType: Devirtualize with EqualityComparer&lt;TValue&gt;.Default intrinsic</span>                i--; <span class="hljs-comment">// Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.</span>                <span class="hljs-keyword">do</span>                &#123;                    <span class="hljs-keyword">if</span> ((uint)i &gt;= (uint)entries.Length)                     &#123;<span class="hljs-comment">// Initialize(int capacity)初始化时，int[] buckets = new int[size]，所以如果i==0，说明找不到元素</span>                        <span class="hljs-keyword">goto</span> ReturnNotFound;                    &#125;                    entry = <span class="hljs-keyword">ref</span> entries[i];                    <span class="hljs-keyword">if</span> (entry.hashCode == hashCode &amp;&amp; EqualityComparer&lt;TKey&gt;.Default.Equals(entry.key, key))                    &#123;<span class="hljs-comment">// 只有在hashCode相等和Equals返回true的同时才认为两个元素相同</span>                        <span class="hljs-keyword">goto</span> ReturnFound;                    &#125;                    i = entry.next;<span class="hljs-comment">// 检查下一个hashCode相同的元素</span>                    collisionCount++;<span class="hljs-comment">// 记录哈希值冲突数（若不理解，可到下方介绍Add方法前提供的链接了解）</span>                &#125; <span class="hljs-keyword">while</span> (collisionCount &lt;= (uint)entries.Length);                <span class="hljs-comment">// The chain of entries forms a loop; which means a concurrent update has happened.</span>                <span class="hljs-comment">// Break out of the loop and throw, rather than looping forever.</span>                <span class="hljs-comment">// 这两句的意思是当跳出上面的while循环时，说明有并发的update事件发生，则抛出相应的异常。这也说明Dictionary并不是线程安全的。</span>                <span class="hljs-keyword">goto</span> ConcurrentOperation;            &#125;            <span class="hljs-keyword">else</span><span class="hljs-comment">// TKey为非值类型</span>            &#123;                <span class="hljs-comment">// Object type: Shared Generic, EqualityComparer&lt;TValue&gt;.Default won&#x27;t devirtualize</span>                <span class="hljs-comment">// https://github.com/dotnet/runtime/issues/10050</span>                <span class="hljs-comment">// So cache in a local rather than get EqualityComparer per loop iteration</span>                EqualityComparer&lt;TKey&gt; defaultComparer = EqualityComparer&lt;TKey&gt;.Default;       <span class="hljs-comment">// ...省略代码，感兴趣去页面底部链接查看源码</span>            &#125;        &#125;        <span class="hljs-keyword">else</span><span class="hljs-comment">// TKey为string类型，或已传递comparer参数</span>        &#123;            uint hashCode = (uint)comparer.GetHashCode(key);            <span class="hljs-comment">// ...省略代码，感兴趣去页面底部链接查看源码</span>        &#125;    &#125;    <span class="hljs-keyword">goto</span> ReturnNotFound;    ConcurrentOperation:    ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();    ReturnFound:    <span class="hljs-keyword">ref</span> TValue <span class="hljs-keyword">value</span> = <span class="hljs-keyword">ref</span> entry.<span class="hljs-keyword">value</span>;    Return:    <span class="hljs-keyword">return</span> <span class="hljs-keyword">ref</span> <span class="hljs-keyword">value</span>;    ReturnNotFound:    <span class="hljs-keyword">value</span> = <span class="hljs-keyword">ref</span> Unsafe.NullRef&lt;TValue&gt;();    <span class="hljs-keyword">goto</span> Return;&#125;</code></pre></div><blockquote><p>if (entry.hashCode == hashCode &amp;&amp; EqualityComparer<TKey>.Default.Equals(entry.key, key)) { goto ReturnFound; }</p></blockquote><p>所以需要hashCode相同并且comparer.Equals(entries[i].key, key)返回true才认为两个Key一样，因为重写了Equals()，所以<code>comparer.Equals(entries[i].key, key)</code>返回的是true，而在没有重写GetHashCode()时，默认使用<code>Object.GetHashCode()</code>获取hashCode，我没有找到这个函数的实现，但基本可以确定跟对象的存储地址是有关系的，而我们是<code>new</code>了一个对象去找Key的，所以得到的hashCode必然跟字典中的Key的hashCode不一致，所以会出现这样的现象。</p><p>所以必须同时重写<code>Equals()</code>和<code>GetHashCode()</code>，比如在这个例子中，根据Name和Birth确定是否同一只Cat，</p><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetHashCode</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> (Name + Birth).GetHashCode();&#125;</code></pre></div><p>此时调用的是<code>string.GetHashCode()</code>，生成的哈希值只与string有关，只要string一样，得到的hashCode是一样的。</p><br><hr><p><font size=4>Dictionary的基本原理其实就是利用一个hash表对Key和Key_Value进行存储和寻址。要看懂源码先要有点<a href="https://blog.csdn.net/u011109881/article/details/80379505">哈希表</a>相关的基础，没有数据结构基础的慢慢看也不难懂。</font></p><h2 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h2><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">TKey key, TValue <span class="hljs-keyword">value</span></span>)</span> &#123;    <span class="hljs-built_in">bool</span> modified = TryInsert(key, <span class="hljs-keyword">value</span>, InsertionBehavior.ThrowOnExisting);    Debug.Assert(modified); <span class="hljs-comment">// If there was an existing key and the Add failed, an exception will already have been thrown.</span>&#125;</code></pre></div><p>再看<code>TryInsert()</code></p><p>这里有两个关键的变量<code>_entries</code>和<code>_buckets</code></p><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-keyword">private</span> Entry[]? _entries;<span class="hljs-comment">// 按下标顺序存储每一个元素、对应的hashCode、下一个entry的下标</span><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[]? _buckets;<span class="hljs-comment">// 存储entries下标（+1）（.Net Framework里的buckets无需+1）的哈希表，用元素的hashCode对buckets.Length取余作为下标可快速找到对应的entry</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">struct</span> Entry &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> hashCode;    <span class="hljs-comment">// Lower 31 bits of hash code, -1 if unused</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> next;        <span class="hljs-comment">// Index of next entry, -1 if last</span>    <span class="hljs-keyword">public</span> TKey key;           <span class="hljs-comment">// Key of entry</span>    <span class="hljs-keyword">public</span> TValue <span class="hljs-keyword">value</span>;         <span class="hljs-comment">// Value of entry</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TryInsert</span>(<span class="hljs-params">TKey key, TValue <span class="hljs-keyword">value</span>, InsertionBehavior behavior</span>)</span> &#123;    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)    &#123;        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);    &#125;    <span class="hljs-keyword">if</span> (_buckets == <span class="hljs-literal">null</span>)<span class="hljs-comment">// 如果_buckets为null要先初始化</span>    &#123;        Initialize(<span class="hljs-number">0</span>);    &#125;    Debug.Assert(_buckets != <span class="hljs-literal">null</span>);    Entry[]? entries = _entries;    Debug.Assert(entries != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;expected entries to be non-null&quot;</span>);    IEqualityComparer&lt;TKey&gt;? comparer = _comparer;    uint hashCode = (uint)((comparer == <span class="hljs-literal">null</span>) ? key.GetHashCode() : comparer.GetHashCode(key));    uint collisionCount = <span class="hljs-number">0</span>;    <span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> bucket = <span class="hljs-function"><span class="hljs-keyword">ref</span> <span class="hljs-title">GetBucket</span>(<span class="hljs-params">hashCode</span>)</span>;<span class="hljs-comment">// hashCode取余作为新元素的buckets下标</span>    <span class="hljs-built_in">int</span> i = bucket - <span class="hljs-number">1</span>; <span class="hljs-comment">// Value in _buckets is 1-based</span><span class="hljs-comment">// 下面的几个if else只是针对TKey类型的不同（或者有无传递comparer参数）而使用对应的EqualityComparer&lt;TValue&gt;去做比较，代码逻辑完全一样，所以这里只讲其中的一种情况。</span>    <span class="hljs-keyword">if</span> (comparer == <span class="hljs-literal">null</span>)    &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(TKey).IsValueType)        &#123;            <span class="hljs-comment">// ValueType: Devirtualize with EqualityComparer&lt;TValue&gt;.Default intrinsic</span>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)            &#123;                <span class="hljs-comment">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span>                <span class="hljs-comment">// Test uint in if rather than loop condition to drop range check for following array access</span>                <span class="hljs-keyword">if</span> ((uint)i &gt;= (uint)entries.Length)                &#123;<span class="hljs-comment">// Initialize(int capacity)初始化时，int[] buckets = new int[size]，所以如果i==0，说明找不到元素</span>                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-comment">// 查找表中是否存在相同元素</span>                <span class="hljs-keyword">if</span> (entries[i].hashCode == hashCode &amp;&amp; EqualityComparer&lt;TKey&gt;.Default.Equals(entries[i].key, key))                &#123;                    <span class="hljs-keyword">if</span> (behavior == InsertionBehavior.OverwriteExisting)                    &#123;<span class="hljs-comment">// 若标志位允许覆写，则覆写</span>                        entries[i].<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                    &#125;                    <span class="hljs-keyword">if</span> (behavior == InsertionBehavior.ThrowOnExisting)                    &#123;<span class="hljs-comment">// 若标志位不允许覆写，则抛出异常</span>                        ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);                    &#125;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                &#125;                i = entries[i].next;<span class="hljs-comment">// 检查下一个hashCode相同的元素</span>                collisionCount++;<span class="hljs-comment">// 记录哈希值冲突数（若不理解，可到下方介绍Add方法前提供的链接了解）</span>                <span class="hljs-keyword">if</span> (collisionCount &gt; (uint)entries.Length)                &#123;                    <span class="hljs-comment">// The chain of entries forms a loop; which means a concurrent update has happened.</span>                    <span class="hljs-comment">// Break out of the loop and throw, rather than looping forever.</span>                    <span class="hljs-comment">// 这两句的意思是当跳出上面的while循环时，说明有并发的update事件发生，则抛出相应的异常。这也说明Dictionary并不是线程安全的。</span>                    ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();                &#125;            &#125;        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-comment">// ...省略代码，感兴趣去页面底部链接查看源码</span>        &#125;    &#125;    <span class="hljs-keyword">else</span>    &#123;            <span class="hljs-comment">// ...省略代码，感兴趣去页面底部链接查看源码</span>    &#125;    <span class="hljs-built_in">int</span> index;    <span class="hljs-comment">// _freeCount只有在Remove元素之后才可能大于0，此时将新元素插入entries空位</span>    <span class="hljs-keyword">if</span> (_freeCount &gt; <span class="hljs-number">0</span>)    &#123;        index = _freeList;<span class="hljs-comment">// 取上次被Remove的元素的下标</span>        Debug.Assert((StartOfFreeList - entries[_freeList].next) &gt;= <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;shouldn&#x27;t overflow because `next` cannot underflow&quot;</span>);        _freeList = StartOfFreeList - entries[_freeList].next;<span class="hljs-comment">// 指向上一个被Remove的元素的坐标，若没有则为StartOfFreeList-0(StartOfFreeList=-3)。这里我也没搞懂为什么要做一个偏移，在Remove方法里也有对应的操作。</span>        _freeCount--;<span class="hljs-comment">// 闲置数减一</span>    &#125;    <span class="hljs-keyword">else</span>    &#123;<span class="hljs-comment">// 如果_entries空间不够用了，就对_entries和_buckets进行扩容</span>        <span class="hljs-built_in">int</span> count = _count;        <span class="hljs-keyword">if</span> (count == entries.Length)        &#123;            Resize();            bucket = <span class="hljs-function"><span class="hljs-keyword">ref</span> <span class="hljs-title">GetBucket</span>(<span class="hljs-params">hashCode</span>)</span>;        &#125;        index = count;        _count = count + <span class="hljs-number">1</span>;        entries = _entries;    &#125;    <span class="hljs-keyword">ref</span> Entry entry = <span class="hljs-keyword">ref</span> entries![index];    entry.hashCode = hashCode;    entry.next = bucket - <span class="hljs-number">1</span>; <span class="hljs-comment">// Value in _buckets is 1-based// [1]</span>    entry.key = key;    entry.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;    bucket = index + <span class="hljs-number">1</span>; <span class="hljs-comment">// Value in _buckets is 1-based// [2]</span>    <span class="hljs-comment">// 这里标记的[1][2]两句是关键，</span>    <span class="hljs-comment">// 当存储的元素作为当前hashCode的第一个元素时，entry.next = bucket - 1 = 0，bucket置为该元素的下标</span>    <span class="hljs-comment">// 而后每一次存储有带着相同哈希值Key的元素时，next指向上一个带着相同哈希值Key的元素，bucket置为新元素的下标</span>    _version++;    <span class="hljs-comment">// 当对Dictionary进行添加新元素、手动扩容或最小化容量操作时，_version++</span>    <span class="hljs-comment">// 扩容：调用EnsureCapacity(int capacity)且需要扩容时，_version++</span>    <span class="hljs-comment">// 最小化容量：调用TrimExcess()或TrimExcess(int capacity)且可以或需要调整容量时，_version++</span>    <span class="hljs-comment">// 不同于.Net Framework版本的Dictionary在“增、改、删”时，version++</span>    <span class="hljs-comment">// 当TKey为非值类型的元素的collisionCount（新增元素Key的hashCode的冲突数） &gt; HashHelpers.HashCollisionThreshold（设定的最大冲突数），</span>    <span class="hljs-comment">// 并且使用NonRandomizedStringEqualityComparer类型的comparer时，会进行对表的Resize处理，</span>    <span class="hljs-comment">// 并使用对应的RandomizedStringEqualityComparer（大概是性能因素）</span>    <span class="hljs-comment">// Value types never rehash</span>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">typeof</span>(TKey).IsValueType &amp;&amp; collisionCount &gt; HashHelpers.HashCollisionThreshold &amp;&amp; comparer <span class="hljs-keyword">is</span> NonRandomizedStringEqualityComparer)    &#123;        <span class="hljs-comment">// If we hit the collision threshold we&#x27;ll need to switch to the comparer which is using randomized string hashing</span>        <span class="hljs-comment">// i.e. EqualityComparer&lt;string&gt;.Default.</span>        Resize(entries.Length, <span class="hljs-literal">true</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><center class="half">    <img src="https://i.loli.net/2021/01/15/xTbrcVZypBkPKa3.png" alt="" style="zoom:67%;" />    &nbsp;&nbsp;-->&nbsp;&nbsp;    <img src="https://i.loli.net/2021/01/15/DlwnE9crYICA8O4.png" alt="" style="zoom:67%;" /></center><p>左图的Dictionary有一个元素，entries[0].hashCode = 8，8 % buckets.Length = 1，因此，entries[0].next = buckets[1] - 1 = -1，buckets[1] = 0 + 1 = 1，实际指向entries[0]。</p><p>此时插入第二个元素，entries[1].hashCode = 15，15 % buckets.Length = 1，因此，entries[1].next = buckets[1] - 1 = 0，buckets[1] = 1 + 1 = 2，实际指向entries[1]。</p><h2 id="Resize"><a href="#Resize" class="headerlink" title="Resize"></a>Resize</h2><p>Resize()会在字典，也就是entries容量不够时执行，对字典进行扩展。</p><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Resize</span>(<span class="hljs-params"></span>)</span> =&gt; Resize(HashHelpers.ExpandPrime(_count), <span class="hljs-literal">false</span>);<span class="hljs-comment">// HashHelpers.ExpandPrime(count)方法调用GetPrime(2 * oldSize)取大于当前元素数量2倍的最小素数作为新哈希表的长度。</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Resize</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> newSize, <span class="hljs-built_in">bool</span> forceNewHashCodes</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// Value types never rehash</span>    Debug.Assert(!forceNewHashCodes || !<span class="hljs-keyword">typeof</span>(TKey).IsValueType);    Debug.Assert(_entries != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;_entries should be non-null&quot;</span>);    Debug.Assert(newSize &gt;= _entries.Length);    Entry[] entries = <span class="hljs-keyword">new</span> Entry[newSize];    <span class="hljs-built_in">int</span> count = _count;    Array.Copy(_entries, entries, count);<span class="hljs-comment">// 复制旧元素到新表</span>    <span class="hljs-comment">// 如果TKey不是值类型并且使用NonRandomizedStringEqualityComparer类型的comparer，则强制重新获取hashCode</span>    <span class="hljs-comment">// 使用RandomizedStringEqualityComparer类型的comparer大概是性能因素，但为什么要重新获取hashCode，暂时不明白</span>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">typeof</span>(TKey).IsValueType &amp;&amp; forceNewHashCodes)    &#123;        Debug.Assert(_comparer <span class="hljs-keyword">is</span> NonRandomizedStringEqualityComparer);        _comparer = (IEqualityComparer&lt;TKey&gt;)((NonRandomizedStringEqualityComparer)_comparer).GetRandomizedEqualityComparer();        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)        &#123;            <span class="hljs-keyword">if</span> (entries[i].next &gt;= <span class="hljs-number">-1</span>)            &#123;                entries[i].hashCode = (uint)_comparer.GetHashCode(entries[i].key);            &#125;        &#125;        <span class="hljs-keyword">if</span> (ReferenceEquals(_comparer, EqualityComparer&lt;TKey&gt;.Default))        &#123;            _comparer = <span class="hljs-literal">null</span>;        &#125;    &#125;    <span class="hljs-comment">// Assign member variables after both arrays allocated to guard against corruption from OOM if second fails</span>    _buckets = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[newSize];    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> TARGET_64BIT</span>        _fastModMultiplier = HashHelpers.GetFastModMultiplier((uint)newSize);    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>        <span class="hljs-comment">// 对所有元素hashCode重新取余，重设下标</span>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)        &#123;            <span class="hljs-keyword">if</span> (entries[i].next &gt;= <span class="hljs-number">-1</span>)            &#123;<span class="hljs-comment">// 过滤Remove后的闲置位</span>                <span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> bucket = <span class="hljs-function"><span class="hljs-keyword">ref</span> <span class="hljs-title">GetBucket</span>(<span class="hljs-params">entries[i].hashCode</span>)</span>;                entries[i].next = bucket - <span class="hljs-number">1</span>; <span class="hljs-comment">// Value in _buckets is 1-based</span>                bucket = i + <span class="hljs-number">1</span>;            &#125;        &#125;    _entries = entries;&#125;</code></pre></div><h2 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h2><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Remove</span>(<span class="hljs-params">TKey key, [MaybeNullWhen(<span class="hljs-literal">false</span></span>)] <span class="hljs-keyword">out</span> TValue <span class="hljs-keyword">value</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// This overload is a copy of the overload Remove(TKey key) with one additional</span>    <span class="hljs-comment">// statement to copy the value for entry being removed into the output parameter.</span>    <span class="hljs-comment">// Code has been intentionally duplicated for performance reasons.</span>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)    &#123;        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);    &#125;    <span class="hljs-keyword">if</span> (_buckets != <span class="hljs-literal">null</span>)    &#123;        Debug.Assert(_entries != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;entries should be non-null&quot;</span>);        uint collisionCount = <span class="hljs-number">0</span>;        uint hashCode = (uint)(_comparer?.GetHashCode(key) ?? key.GetHashCode());        <span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> bucket = <span class="hljs-function"><span class="hljs-keyword">ref</span> <span class="hljs-title">GetBucket</span>(<span class="hljs-params">hashCode</span>)</span>;        Entry[]? entries = _entries;        <span class="hljs-built_in">int</span> last = <span class="hljs-number">-1</span>;<span class="hljs-comment">// 记录上一个元素的下标</span>        <span class="hljs-built_in">int</span> i = bucket - <span class="hljs-number">1</span>; <span class="hljs-comment">// Value in buckets is 1-based</span>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>)<span class="hljs-comment">// i==0时跳出while，说明key不存在</span>        &#123;            <span class="hljs-keyword">ref</span> Entry entry = <span class="hljs-keyword">ref</span> entries[i];            <span class="hljs-keyword">if</span> (entry.hashCode == hashCode &amp;&amp; (_comparer?.Equals(entry.key, key) ?? EqualityComparer&lt;TKey&gt;.Default.Equals(entry.key, key)))            &#123;                <span class="hljs-keyword">if</span> (last &lt; <span class="hljs-number">0</span>)                &#123;<span class="hljs-comment">// last &lt; 0 说明，该hashCode对应元素只有一个。</span>                    bucket = entry.next + <span class="hljs-number">1</span>; <span class="hljs-comment">// Value in buckets is 1-based</span>                    <span class="hljs-comment">// 其实就是bucket = 0</span>                &#125;                <span class="hljs-keyword">else</span>                &#123;                    entries[last].next = entry.next;<span class="hljs-comment">// 把前后两个entry链接起来</span>                &#125;                <span class="hljs-keyword">value</span> = entry.<span class="hljs-keyword">value</span>;                Debug.Assert((StartOfFreeList - _freeList) &lt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;shouldn&#x27;t underflow because max hashtable length is MaxPrimeArrayLength = 0x7FEFFFFD(2146435069) _freelist underflow threshold 2147483646&quot;</span>);                entry.next = StartOfFreeList - _freeList;<span class="hljs-comment">// next指向上一个被Remove的元素的坐标，若没有则为StartOfFreeList-1(StartOfFreeList=-3)</span>                <span class="hljs-keyword">if</span> (RuntimeHelpers.IsReferenceOrContainsReferences&lt;TKey&gt;())                &#123;<span class="hljs-comment">// 若引用不为空，则置为默认值（“!”为null包容操作符，作用是不发出相关警告，详细请看本博客一篇介绍）</span>                    entry.key = <span class="hljs-literal">default</span>!;                &#125;                <span class="hljs-keyword">if</span> (RuntimeHelpers.IsReferenceOrContainsReferences&lt;TValue&gt;())                &#123;                    entry.<span class="hljs-keyword">value</span> = <span class="hljs-literal">default</span>!;                &#125;                _freeList = i;<span class="hljs-comment">// 置为最新被移除元素的坐标</span>                _freeCount++;<span class="hljs-comment">// entries闲置数加一</span>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            last = i;<span class="hljs-comment">// 记录上一个元素的下标</span>            i = entry.next;            collisionCount++;            <span class="hljs-keyword">if</span> (collisionCount &gt; (uint)entries.Length)            &#123;                <span class="hljs-comment">// The chain of entries forms a loop; which means a concurrent update has happened.</span>                <span class="hljs-comment">// Break out of the loop and throw, rather than looping forever.</span>                <span class="hljs-comment">// 这两句的意思是当collisionCount &gt; (uint)entries.Length时</span>                <span class="hljs-comment">// 说明有并发的update事件发生，则抛出相应的异常。这也说明Dictionary并不是线程安全的。</span>                ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();            &#125;        &#125;    &#125;    <span class="hljs-keyword">value</span> = <span class="hljs-literal">default</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre></div><h2 id="Clear"><a href="#Clear" class="headerlink" title="Clear"></a>Clear</h2><p>为了提高效率，Clear函数没有对_entries和_buckets置null，只是把相关的变量重新初始化了。也符合逻辑，如果置null，那我为什么不直接new一个新的Dictionary呢。</p><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">int</span> count = _count;    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>)    &#123;        Debug.Assert(_buckets != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;_buckets should be non-null&quot;</span>);        Debug.Assert(_entries != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;_entries should be non-null&quot;</span>);        Array.Clear(_buckets, <span class="hljs-number">0</span>, _buckets.Length);        _count = <span class="hljs-number">0</span>;        _freeList = <span class="hljs-number">-1</span>;        _freeCount = <span class="hljs-number">0</span>;        Array.Clear(_entries, <span class="hljs-number">0</span>, count);    &#125;&#125;</code></pre></div><p>官方源码：<a href="https://source.dot.net/#System.Private.CoreLib/Dictionary.cs">Dictionary.cs</a></p>]]></content>
    
    
    <categories>
      
      <category>.Net</category>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【源码】浅析Dictionary(mscorlib)源码</title>
    <link href="/2020/08/30/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91%E6%B5%85%E6%9E%90Dictionary(mscorlib)%E6%BA%90%E7%A0%81/"/>
    <url>/2020/08/30/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91%E6%B5%85%E6%9E%90Dictionary(mscorlib)%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p><strong>注：本文参考的源码来自mscorlib.dll，会有部分代码逻辑不同于.Net Core的Dictionary，已在另一篇博文对比介绍</strong><a href="../../../../2020/09/15/【源码】浅看Dictionary(System.Private.CoreLib)源码/">【源码】浅看Dictionary(System.Private.CoreLib)源码</a></p><p>在自定义类重写<code>Equals()</code>和<code>GetHashCode()</code>的时候有些好奇，所以想看看Dictionary查找Key和存储键值对的原理。</p><p>下面通过看看几个最常用的Dictionary的方法，了解一下Dictionary的实现原理。</p><h2 id="GetHashCode"><a href="#GetHashCode" class="headerlink" title="GetHashCode"></a>GetHashCode</h2><p>首先看看如果在重写<code>Equals()</code>的时候不重写<code>GetHashCode()</code>会出现什么情况</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span></span><span class="hljs-class"></span>&#123;    public string Name;    public string Birth;    public bool Equals(Cat cat)    &#123;        <span class="hljs-keyword">if</span> (cat is <span class="hljs-literal">null</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        Console.WriteLine(<span class="hljs-string">&quot;自定义_Cat&quot;</span>);        <span class="hljs-keyword">return</span> Name == cat.Name &amp;&amp; Birth == cat.Birth;    &#125;    public override bool Equals(object obj) =&gt; Equals(obj <span class="hljs-keyword">as</span> Cat);&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> Main(string[] args)&#123;    Dictionary&lt;Cat, string&gt; cats = <span class="hljs-keyword">new</span> Dictionary&lt;Cat, string&gt;()    &#123;        &#123; <span class="hljs-keyword">new</span> Cat &#123; Name=<span class="hljs-string">&quot;小黑&quot;</span>, Birth = <span class="hljs-string">&quot;2020-2-1&quot;</span> &#125;, <span class="hljs-string">&quot;小黑&quot;</span> &#125;,        &#123; <span class="hljs-keyword">new</span> Cat &#123; Name=<span class="hljs-string">&quot;小黄&quot;</span>, Birth = <span class="hljs-string">&quot;2020-4-1&quot;</span> &#125;, <span class="hljs-string">&quot;小黄&quot;</span> &#125;,        &#123; <span class="hljs-keyword">new</span> Cat &#123; Name=<span class="hljs-string">&quot;憨豆&quot;</span>, Birth = <span class="hljs-string">&quot;2020-5-1&quot;</span> &#125;, <span class="hljs-string">&quot;憨豆&quot;</span> &#125;,        &#123; <span class="hljs-keyword">new</span> Cat &#123; Name=<span class="hljs-string">&quot;小黑&quot;</span>, Birth = <span class="hljs-string">&quot;2020-2-1&quot;</span> &#125;, <span class="hljs-string">&quot;小黑2&quot;</span> &#125;,    &#125;;    <span class="hljs-keyword">var</span> xiaohei = <span class="hljs-keyword">new</span> Cat &#123; Name = <span class="hljs-string">&quot;小黑&quot;</span>, Birth = <span class="hljs-string">&quot;2020-2-1&quot;</span> &#125;;    Console.WriteLine(cats.ContainsKey(xiaohei));&#125;<span class="hljs-comment">// 输出</span><span class="hljs-comment">// False</span></code></pre></div><p>可以看到虽然有两个“一样”的Key，<code>&#123; new Cat &#123; Name=&quot;小黑&quot;, Birth = &quot;2020-2-1&quot; &#125;, &quot;小黑&quot; &#125;</code>和<code>&#123; new Cat &#123; Name=&quot;小黑&quot;, Birth = &quot;2020-2-1&quot; &#125;, &quot;小黑2&quot; &#125;</code>，但是Dictionary还是正常初始化了，而在ContainsKey()时找不到Key。</p><h2 id="ContainsKey"><a href="#ContainsKey" class="headerlink" title="ContainsKey"></a>ContainsKey</h2><p>源码中的ContainsKey()直接return<code>FindEntry(key) &gt;= 0;</code>，再看看FindEntry()的实现</p><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-title">FindEntry</span>(<span class="hljs-params">TKey key</span>)</span> &#123;    <span class="hljs-keyword">if</span>( key == <span class="hljs-literal">null</span>) &#123;        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);    &#125;    <span class="hljs-keyword">if</span> (buckets != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-built_in">int</span> hashCode = comparer.GetHashCode(key) &amp; <span class="hljs-number">0x7FFFFFFF</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = buckets[hashCode % buckets.Length]; i &gt;= <span class="hljs-number">0</span>; i = entries[i].next) &#123;            <span class="hljs-keyword">if</span> (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) <span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;</code></pre></div><blockquote><p>if (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) return i;</p></blockquote><p>所以需要hashCode相同并且comparer.Equals(entries[i].key, key)返回true才认为两个Key一样，因为重写了Equals()，所以<code>comparer.Equals(entries[i].key, key)</code>返回的是true，而在没有重写GetHashCode()时，默认使用<code>Object.GetHashCode()</code>获取hashCode，我没有找到这个函数的实现，但基本可以确定跟对象的存储地址是有关系的，而我们是<code>new</code>了一个对象去找Key的，所以得到的hashCode必然跟字典中的Key的hashCode不一致，所以会出现这样的现象。</p><p>所以必须同时重写<code>Equals()</code>和<code>GetHashCode()</code>，比如在这个例子中，根据Name和Birth确定是否同一只Cat，</p><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetHashCode</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> (Name + Birth).GetHashCode();&#125;</code></pre></div><p>此时调用的是<code>string.GetHashCode()</code>，生成的哈希值只与string有关，只要string一样，得到的hashCode是一样的。</p><br><hr><p><font size=4>Dictionary的基本原理其实就是利用一个hash表对Key和Key_Value进行存储和寻址。要看懂源码先要有点<a href="https://blog.csdn.net/u011109881/article/details/80379505">哈希表</a>相关的基础，没有数据结构基础的慢慢看也不难懂。</font></p><h2 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h2><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">TKey key, TValue <span class="hljs-keyword">value</span></span>)</span> &#123;    Insert(key, <span class="hljs-keyword">value</span>, <span class="hljs-literal">true</span>);&#125;</code></pre></div><p>再看<code>Insert()</code></p><p>这里有两个关键的变量<code>entries</code>和<code>buckets</code></p><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-keyword">private</span> Entry[] entries;<span class="hljs-comment">// 按下标顺序存储每一个元素、对应的hashCode、下一个entry的下标</span><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] buckets;<span class="hljs-comment">// 存储entries下标的哈希表，用元素的hashCode对buckets.Length取余作为下标可快速找到对应的entry</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">struct</span> Entry &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> hashCode;    <span class="hljs-comment">// Lower 31 bits of hash code, -1 if unused</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> next;        <span class="hljs-comment">// Index of next entry, -1 if last</span>    <span class="hljs-keyword">public</span> TKey key;           <span class="hljs-comment">// Key of entry</span>    <span class="hljs-keyword">public</span> TValue <span class="hljs-keyword">value</span>;         <span class="hljs-comment">// Value of entry</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span>(<span class="hljs-params">TKey key, TValue <span class="hljs-keyword">value</span>, <span class="hljs-built_in">bool</span> <span class="hljs-keyword">add</span></span>)</span> &#123;    <span class="hljs-keyword">if</span>( key == <span class="hljs-literal">null</span> ) &#123;        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);    &#125;    <span class="hljs-keyword">if</span> (buckets == <span class="hljs-literal">null</span>) Initialize(<span class="hljs-number">0</span>);<span class="hljs-comment">// 如果buckets为null要先初始化</span>    <span class="hljs-built_in">int</span> hashCode = comparer.GetHashCode(key) &amp; <span class="hljs-number">0x7FFFFFFF</span>;    <span class="hljs-built_in">int</span> targetBucket = hashCode % buckets.Length;    <span class="hljs-comment">// hashCode取余作为新元素的buckets下标</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> FEATURE_RANDOMIZED_STRING_HASHING</span>    <span class="hljs-built_in">int</span> collisionCount = <span class="hljs-number">0</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-comment">// 下面整个for从buckets[targetBucket]开始，取entries[buckets[targetBucket]]跟新元素的Key对比，如果没有遇到相同的Key才添加新元素</span>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = buckets[targetBucket]; i &gt;= <span class="hljs-number">0</span>; i = entries[i].next) &#123;        <span class="hljs-comment">// 只有在hashCode相等和Equals返回true的同时才认为两个元素相同</span>        <span class="hljs-keyword">if</span> (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">add</span>) &#123;<span class="hljs-comment">// 在用`[]`进行操作时add为false，更新元素value</span>                ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate); <span class="hljs-comment">// 存在相同元素抛出异常</span>            &#125;            entries[i].<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;            version++;<span class="hljs-comment">// 当对Dictionary进行Add或Update或Remove“增、改、删”操作时，Dictionary的version加一</span>            <span class="hljs-keyword">return</span>;        &#125; <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> FEATURE_RANDOMIZED_STRING_HASHING</span>        collisionCount++;<span class="hljs-comment">// 记录冲突数，理解这个需要先了解上面提到的哈希表结构</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    &#125;    <span class="hljs-built_in">int</span> index;    <span class="hljs-comment">// freeCount只有在Remove元素之后才可能大于0，此时将新元素插入entries空位</span>    <span class="hljs-keyword">if</span> (freeCount &gt; <span class="hljs-number">0</span>) &#123;        index = freeList;<span class="hljs-comment">// 取上次被Remove的元素的下标</span>        freeList = entries[index].next;<span class="hljs-comment">// 指向上一个被Remove的元素的坐标，若没有则为-1</span>        freeCount--;<span class="hljs-comment">// 闲置数减一</span>    &#125;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 如果entries空间不够用了，就对entries和buckets进行扩容</span>        <span class="hljs-keyword">if</span> (count == entries.Length)        &#123;            Resize();            targetBucket = hashCode % buckets.Length;        &#125;        index = count;        count++;    &#125;    entries[index].hashCode = hashCode;    entries[index].next = buckets[targetBucket];<span class="hljs-comment">// [1]</span>    entries[index].key = key;    entries[index].<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;    buckets[targetBucket] = index;<span class="hljs-comment">// [2]</span>    <span class="hljs-comment">// 这里标记的[1][2]两句是关键，</span>    <span class="hljs-comment">// 当存储的元素作为当前hashCode的第一个元素时，next = buckets[targetBucket] = -1，buckets[targetBucket]置为该元素的下标</span>    <span class="hljs-comment">// 而后每一次存储有带着相同哈希值Key的元素时，next指向上一个带着相同哈希值Key的元素，buckets[targetBucket]置为新元素的下标</span>    version++;<span class="hljs-comment">// 当对Dictionary进行Add或Update或Remove“增、改、删”操作时，Dictionary的version加一</span><span class="hljs-comment">// 下面代码是当collisionCount（新增元素Key的hashCode的冲突数） &gt; HashHelpers.HashCollisionThreshold（设定的最大冲突数）时会进行对表的Resize处理，我懒得细看了。</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> FEATURE_RANDOMIZED_STRING_HASHING</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> FEATURE_CORECLR</span>    <span class="hljs-comment">// In case we hit the collision threshold we&#x27;ll need to switch to the comparer which is using randomized string hashing</span>    <span class="hljs-comment">// in this case will be EqualityComparer&lt;string&gt;.Default.</span>    <span class="hljs-comment">// Note, randomized string hashing is turned on by default on coreclr so EqualityComparer&lt;string&gt;.Default will </span>    <span class="hljs-comment">// be using randomized string hashing</span>    <span class="hljs-keyword">if</span> (collisionCount &gt; HashHelpers.HashCollisionThreshold &amp;&amp; comparer == NonRandomizedStringEqualityComparer.Default)     &#123;s        comparer = (IEqualityComparer&lt;TKey&gt;) EqualityComparer&lt;<span class="hljs-built_in">string</span>&gt;.Default;        Resize(entries.Length, <span class="hljs-literal">true</span>);    &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>    <span class="hljs-keyword">if</span>(collisionCount &gt; HashHelpers.HashCollisionThreshold &amp;&amp; HashHelpers.IsWellKnownEqualityComparer(comparer))     &#123;        comparer = (IEqualityComparer&lt;TKey&gt;) HashHelpers.GetRandomizedEqualityComparer(comparer);        Resize(entries.Length, <span class="hljs-literal">true</span>);    &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> // FEATURE_CORECLR</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>&#125;</code></pre></div><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><center class="half">    <img src="https://i.loli.net/2021/01/15/g7d6oMs4ki3IWTu.png" alt="" style="zoom:67%;" />    &nbsp;&nbsp;-->&nbsp;&nbsp;    <img src="https://i.loli.net/2021/01/15/2dwhY5gTsM8itck.png" alt="" style="zoom:67%;" /></center><p>左图的Dictionary有一个元素，entries[0].hashCode = 8，8 % buckets.Length = 1，因此，entries[0].next = buckets[1] = -1，buckets[1] = 0，实际指向entries[0]。</p><p>此时插入第二个元素，entries[1].hashCode = 15，15 % buckets.Length = 1，因此，entries[1].next = buckets[1] = 0，buckets[1] = 1，实际指向entries[1]。</p><h2 id="Resize"><a href="#Resize" class="headerlink" title="Resize"></a>Resize</h2><p>Resize()会在字典，也就是entries容量不够时执行，对字典进行扩展。</p><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Resize</span>(<span class="hljs-params"></span>)</span> &#123;    Resize(HashHelpers.ExpandPrime(count), <span class="hljs-literal">false</span>);    <span class="hljs-comment">// HashHelpers.ExpandPrime(count)方法调用GetPrime(2 * oldSize)取大于当前元素数量2倍的最小素数作为新哈希表的长度。</span>&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Resize</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> newSize, <span class="hljs-built_in">bool</span> forceNewHashCodes</span>)</span> &#123;    Contract.Assert(newSize &gt;= entries.Length);    <span class="hljs-built_in">int</span>[] newBuckets = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[newSize];    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; newBuckets.Length; i++) newBuckets[i] = <span class="hljs-number">-1</span>;<span class="hljs-comment">// 初始化哈希表内坐标</span>    Entry[] newEntries = <span class="hljs-keyword">new</span> Entry[newSize];    Array.Copy(entries, <span class="hljs-number">0</span>, newEntries, <span class="hljs-number">0</span>, count);<span class="hljs-comment">// 复制旧元素到新表</span>    <span class="hljs-keyword">if</span>(forceNewHashCodes) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;            <span class="hljs-keyword">if</span>(newEntries[i].hashCode != <span class="hljs-number">-1</span>) &#123;                newEntries[i].hashCode = (comparer.GetHashCode(newEntries[i].key) &amp; <span class="hljs-number">0x7FFFFFFF</span>);            &#125;        &#125;    &#125;    <span class="hljs-comment">// // 对所有元素hashCode重新取余，重设下标</span>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;        <span class="hljs-keyword">if</span> (newEntries[i].hashCode &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 过滤Remove后的闲置位</span>            <span class="hljs-built_in">int</span> bucket = newEntries[i].hashCode % newSize;            newEntries[i].next = newBuckets[bucket];            newBuckets[bucket] = i;        &#125;    &#125;    buckets = newBuckets;    entries = newEntries;&#125;</code></pre></div><h2 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h2><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Remove</span>(<span class="hljs-params">TKey key</span>)</span> &#123;    <span class="hljs-keyword">if</span>(key == <span class="hljs-literal">null</span>) &#123;        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);    &#125;    <span class="hljs-keyword">if</span> (buckets != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-built_in">int</span> hashCode = comparer.GetHashCode(key) &amp; <span class="hljs-number">0x7FFFFFFF</span>;        <span class="hljs-built_in">int</span> bucket = hashCode % buckets.Length;        <span class="hljs-built_in">int</span> last = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = buckets[bucket]; i &gt;= <span class="hljs-number">0</span>; last = i, i = entries[i].next) &#123;            <span class="hljs-keyword">if</span> (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) &#123;                <span class="hljs-keyword">if</span> (last &lt; <span class="hljs-number">0</span>) &#123;                    buckets[bucket] = entries[i].next;                &#125;                <span class="hljs-keyword">else</span> &#123;                    entries[last].next = entries[i].next;                &#125;                entries[i].hashCode = <span class="hljs-number">-1</span>;<span class="hljs-comment">// hashCode设为-1，做个标记</span>                entries[i].next = freeList;<span class="hljs-comment">// next指向上一个被Remove的元素的坐标，若没有则为-1</span>                entries[i].key = <span class="hljs-literal">default</span>(TKey);                entries[i].<span class="hljs-keyword">value</span> = <span class="hljs-literal">default</span>(TValue);                freeList = i;<span class="hljs-comment">// 置为最新被移除元素的坐标</span>                freeCount++;<span class="hljs-comment">// entries闲置数加一</span>                version++;<span class="hljs-comment">// 当对Dictionary进行Add或Update或Remove（“增、改、删”）操作时，Dictionary的version加一</span>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre></div><h2 id="Clear"><a href="#Clear" class="headerlink" title="Clear"></a>Clear</h2><p>为了提高效率，Clear函数没有对entries和buckets置null，只是把相关的变量重新初始化了。也符合逻辑，如果置null，那我为什么不直接new一个新的Dictionary呢。</p><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; buckets.Length; i++) buckets[i] = <span class="hljs-number">-1</span>;        Array.Clear(entries, <span class="hljs-number">0</span>, count);        freeList = <span class="hljs-number">-1</span>;        count = <span class="hljs-number">0</span>;        freeCount = <span class="hljs-number">0</span>;        version++;    &#125;&#125;</code></pre></div><p>官方源码：<a href="https://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs">Dictionary.cs</a></p>]]></content>
    
    
    <categories>
      
      <category>.Net</category>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【语法】! - null包容操作符</title>
    <link href="/2020/08/29/%E3%80%90%E8%AF%AD%E6%B3%95%E3%80%91!%20_null%20%E5%8C%85%E5%AE%B9%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <url>/2020/08/29/%E3%80%90%E8%AF%AD%E6%B3%95%E3%80%91!%20_null%20%E5%8C%85%E5%AE%B9%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p><code>!</code>  - null forgiving operator</p><p>首先加上nullable的声明，否则将没有相关提示。</p><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-meta">#nullable enable</span><span class="hljs-keyword">namespace</span> <span class="hljs-title">DotNet_5._0_p7</span>&#123;    <span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span>    &#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pet</span> (<span class="hljs-params">Cat? cat, Dog dog</span>)</span><span class="hljs-function"></span>        &#123;            Cat = cat;            Dog = dog;        &#125;        <span class="hljs-keyword">public</span> Cat? Cat;        <span class="hljs-keyword">public</span> Dog Dog;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>        &#123;            <span class="hljs-keyword">return</span> Cat.Name ?? Dog.Name;        &#125;    &#125;    <span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name = <span class="hljs-string">&quot;Cat&quot;</span>;    &#125;    <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>    &#123;        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name = <span class="hljs-string">&quot;Dog&quot;</span>;    &#125;    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>    &#123;        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><span class="hljs-function"></span>        &#123;            Pet pet = <span class="hljs-keyword">new</span> Pet(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);            Console.WriteLine(pet.ToString());            Console.ReadKey();        &#125;    &#125;&#125;</code></pre></div><p>在<code>Cat.Name</code>的<code>Cat</code>下方会出现Warning波浪线</p><blockquote><p>Warning CS8602: Dereference of a possibly null reference</p></blockquote><p><code>new Pet(null, null)</code>的第二个null也会有警告</p><blockquote><p>CS8625 // Cannot convert null literal to non-nullable reference type.</p></blockquote><p>但这只是Warning，实际上还是可以运行程序，然后在<code>Cat.Name</code>处抛出<code>Object reference not set to an instance of an object.</code>的异常。</p><p>如果把<code>ToString</code>改成</p><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (Cat == <span class="hljs-literal">null</span>) Cat = <span class="hljs-keyword">new</span> Cat();    <span class="hljs-keyword">return</span> Cat.Name ?? Dog.Name;&#125;</code></pre></div><p>那将不会有警告，因为编译器已经可以确认<code>Cat</code>不可能为null。</p><p>再作这样的修改</p><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CheckValid</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (Cat == <span class="hljs-literal">null</span>) Cat = <span class="hljs-keyword">new</span> Cat();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;    CheckValid();    <span class="hljs-keyword">return</span> Cat.Name ?? Dog.Name;&#125;</code></pre></div><p><code>Cat.Name</code>出现警告，因为编译器无法得知<code>CheckValid</code>的工作，但实际上<code>Cat</code>已经不可能为null。这个时候就可以用上<code>!</code>运算符</p><p><code>Cat!.Name ?? Dog.Name;</code>，这样就能让编译器不发出警告。注意不是<code>?.</code>，<code>Cat?.Name</code>也不会发出警告，但当<code>Cat</code>为null时，<code>Cat?.Name</code>不会抛出异常而是返回null。</p><p>可以看出来<code>!</code>运算符不像<code>?</code>，<code>!</code>并不对编译结果产生任何影响，只是让编译器的警告跟随代码逻辑，不发出不必要的警告。</p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/null-forgiving">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>.Net</category>
      
      <category>语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并行计算 - 一切皆SynchronizationContext</title>
    <link href="/2020/05/06/Parallel%20Computing%20-%20It&#39;s%20All%20About%20the%20SynchronizationContext/"/>
    <url>/2020/05/06/Parallel%20Computing%20-%20It&#39;s%20All%20About%20the%20SynchronizationContext/</url>
    
    <content type="html"><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>《Parallel Computing - It’s All About the SynchronizationContext》by Stephen Cleary 一文半翻译半总结。</p><!---more---><p><strong><center><font size=5>正文</font></center></strong></p><p><font size=2>名词：<code>context</code>上下文、<code>SynchronizationContext</code>同步上下文</font></p><p>多线程编程可能很难，而且当开始着手这项任务时，有大量的概念和工具需要去学习。为了提供协助，Microsoft .NET Framework 提供了<code>SynchronizationContext</code>类。遗憾的是，很多开发者甚至不知道这个有用的工具。</p><p>不管什么平台（无论是ASP.NET, Windows Forms, Windows Presentation Foundation (WPF), Silverlight 还是其他的），所有的.Net程序都有SynchronizationContext的概念，因此所有的多线程编程人员都能从了解和应用它的过程中获益。</p><h3 id="SynchronizationContext的需求"><a href="#SynchronizationContext的需求" class="headerlink" title="SynchronizationContext的需求"></a>SynchronizationContext的需求</h3><p>多线程程序早在.NET Framework出现之前就已经存在。这些程序经常需要一个线程传递一个工作单元给另一个线程。Windows程序围绕着消息循环，所以许多编程人员利用这个内建的队列传递工作单元。每一个想在这种方式下使用Windows消息队列的多线程程序必需定义它们自己的自定义Windows消息和处理约定。</p><p>当.NET Framework第一次发布时，这种通用模式就被标准化了。.Net唯一支持的GUI应用类型是Windows Forms。但是，框架设计者预料到会有其他模型，因此他们开发了一套通用解决方案。ISynchronizeInvoke诞生了。</p><p>ISynchronizeInvoke背后的理念是一个“源”线程可以将一个委托列入另一“目标”线程队列，选择性等待委托的完成。ISynchronizeInvoke同时提供了一个属性去确定当前代码是否已经运行在目标线程上；在这种情况下，委托的排队就没必要了。Windows Forms提供了唯一的一个ISynchronizeInvoke的实现，以及设计异步组件的一套模式，所以皆大欢喜。</p><p>.NET Framework 2.0包含了很多颠覆性的改变。其中一个重大的提升就是将异步页面引入到ASP.NET架构。在.NET Framework 2.0以前，每一个ASP.NET请求都需要一个线程直到线程完成。这是对线程利用的低效，因为创建一个Web页面通常依赖数据库查询和Web服务调用，而处理请求的线程必需的等待每一个操作的完成。有了异步页面，处理请求的线程可以启动每一个操作然后返回ASP.NET线程池；当操作完成，ASP.NET线程池中的另一个线程将完成请求。</p><p>然而，ISynchronizeInvoke并不是那么适合ASP.NET异步页面架构。ASP.NET异步页面不是关联单一线程，所以使用ISynchronizeInvoke模式开发的异步组件并不能在ASP.NET页面正确地工作。没有将工作列入原始线程队列，异步页面只需维持对未完成操作的计数来确定页面请求何时完成。经过充分的思考和谨慎的设计，ISynchronizeInvoke被SynchronizationContext代替。</p><h3 id="SynchronizationContext的概念"><a href="#SynchronizationContext的概念" class="headerlink" title="SynchronizationContext的概念"></a>SynchronizationContext的概念</h3><p>ISynchronizeInvoke满足两个需求：确定同步是否必要，以及将一个单元工作从一个线程列入另一个线程的队列。SynchronizationContext被设计用来代替ISynchronizeInvoke，但在设计过后，发现它不仅仅是简单的替代。</p><p>SynchronizationContext一方面提供了一种途径去将一个单元工作列入一个context队列中。注意是列入context而不是一个特定的线程。这个区别很重要，因为SynchronizationContext的很多实现不是基于单一、特定的线程。SynchronizationContext并没有一个机制来确定同步是否是必要的，因为这并不总是可行。</p><p>SynchronizationContext的另一方面是每一个线程都有一个“当前”context。一个线程的context未必是独有的，它的context实例可能跟其他线程共享。一个线程改变自己的当前context的可能性是存在的，但这很少见。</p><p>SynchronizationContext的第三个方面是它一直对未完成的操作进行计数。这样就可以使用ASP.NET异步页面和其他需要这种计数的主机。大部分情况下，当SynchronizationContext被捕获时，计数递增，当被捕获的SynchronizationContext将一个完成操作的通知列入context时，计数递减。</p><p>SynchronizationContext还有其他的方面，但它们对大部分编程人员不那么重要。最重要的方面展示在图1中。</p><p><font size=2 color=gray>图一 SynchronizationContext API的各个方面</font></p><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-comment">// The important aspects of the SynchronizationContext APIclass SynchronizationContext</span>&#123;    <span class="hljs-comment">// Dispatch work to the context.</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Post</span>(<span class="hljs-params">..</span>)</span>; <span class="hljs-comment">// (asynchronously)</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Send</span>(<span class="hljs-params">..</span>)</span>; <span class="hljs-comment">// (synchronously)</span>    <span class="hljs-comment">// Keep track of the number of asynchronous operations.</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OperationStarted</span>(<span class="hljs-params"></span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OperationCompleted</span>(<span class="hljs-params"></span>)</span>;    <span class="hljs-comment">// Each thread has a current context.</span>    <span class="hljs-comment">// If &quot;Current&quot; is null, then the thread&#x27;s current context is</span>     <span class="hljs-comment">// &quot;new SynchronizationContext()&quot;, by convention.</span>    <span class="hljs-keyword">static</span> SynchronizationContext Current &#123; <span class="hljs-keyword">get</span>; &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetSynchronizationContext</span>(<span class="hljs-params">SynchronizationContext</span>)</span>;&#125;</code></pre></div><h3 id="SynchronizationContext的实现"><a href="#SynchronizationContext的实现" class="headerlink" title="SynchronizationContext的实现"></a>SynchronizationContext的实现</h3><p>真正的“context”没有被明确定义。不同的框架和主机可以自主定义它们自己的context。了解这些不同的实现和它们的限制可以理清SynchronizationContext可以实现什么和不能实现什么。我会简短地讨论一下这些实现。</p><p><strong>WindowsFormsSynchronizationContext</strong> (System.Windows.Forms.dll: System.Windows.Forms) Windows Forms应用会为创建UI控件的任何线程创建并安装一个WindowsFormsSynchronizationContext作为当前context。这个SynchronizationContext使用UI控件上的ISynchronizeInvoke方法来将委托传递给底层Win32信息循环。这个作为SynchronizationContext的context是一个单一线程。</p><p>所有列入WindowsFormsSynchronizationContext队列的委托一次执行一个；它们按照列队的顺序被一个特定的线程执行。当前的实现为每一个UI线程创建一个WindowsFormsSynchronizationContext。</p>]]></content>
    
    
    <categories>
      
      <category>文章翻译总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>异步编程</tag>
      
      <tag>Task</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Task的一些奇怪现象</title>
    <link href="/2020/05/06/%E5%85%B3%E4%BA%8ETask%E7%9A%84%E5%A5%87%E6%80%AA%E7%8E%B0%E8%B1%A1/"/>
    <url>/2020/05/06/%E5%85%B3%E4%BA%8ETask%E7%9A%84%E5%A5%87%E6%80%AA%E7%8E%B0%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>.Net</category>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>异步编程</tag>
      
      <tag>Task</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Task的使用（未完）</title>
    <link href="/2020/05/02/%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3DotNet%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B_Task/"/>
    <url>/2020/05/02/%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3DotNet%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B_Task/</url>
    
    <content type="html"><![CDATA[<h2 id="Action和Func"><a href="#Action和Func" class="headerlink" title="Action和Func"></a>Action和Func</h2><p>两者其实都是对delegate的封装，使得声明委托的过程更简单，使用起来也更方便。而delegate、Action、Func都使得处理数据更加灵活，因为我们可以创建一个函数接收开发者或客户的数据参数的同时还能根据不同场景接受不同的处理方式。</p><p>Action，顾名思义就是一个“动作”，简单来说就是一个包装了不带返回值函数的委托。可声明不带返回值、接受零个或多个参数的方法的委托。</p><ul><li><p><strong>声明和调用一个Action</strong></p><div class="code-wrapper"><pre><code class="hljs cs"> <span class="hljs-comment">// 1.Lambda表达式</span>Action action = () =&gt; Console.WriteLine(<span class="hljs-string">&quot;Hello&quot;</span>);Action action2 = <span class="hljs-keyword">new</span> Action(() =&gt; Console.WriteLine(<span class="hljs-string">&quot;Hello&quot;</span>));action();action2();<span class="hljs-comment">// 2.用方法声明</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintText</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> text</span>)</span><span class="hljs-function"></span>&#123;    Console.WriteLine(text);&#125;Action&lt;<span class="hljs-built_in">string</span>&gt; action = PrintText;action(<span class="hljs-string">&quot;Hello&quot;</span>);</code></pre></div><p>Func跟Action的唯一区别是Func声明的委托必须有返回值，返回值的类型由<code>&lt;&gt;</code>中的由最右边的类型指定</p></li><li><p><strong>声明和调用一个Func</strong></p><div class="code-wrapper"><pre><code class="hljs cs"> <span class="hljs-comment">// 1.Lambda表达式</span>Func&lt;<span class="hljs-built_in">string</span>&gt; func = () =&gt; &#123;     Console.WriteLine(<span class="hljs-string">&quot;Hello&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;&#125;;Func&lt;<span class="hljs-built_in">string</span>&gt; func2 = <span class="hljs-keyword">new</span> Func&lt;<span class="hljs-built_in">string</span>&gt;(() =&gt; &#123;    Console.WriteLine(<span class="hljs-string">&quot;Hello&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;&#125;);func();func2();<span class="hljs-comment">// 2.用函数声明</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">PrintText</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> text</span>)</span><span class="hljs-function"></span>&#123;    Console.WriteLine(text);    <span class="hljs-keyword">return</span> text.Length;&#125;Func&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt; func = PrintText;Console.WriteLine(func(<span class="hljs-string">&quot;Hello&quot;</span>));</code></pre></div></li></ul><h2 id="Task的出现和基本语法"><a href="#Task的出现和基本语法" class="headerlink" title="Task的出现和基本语法"></a>Task的出现和基本语法</h2><p>以往要并行处理一些事务，我们通常会用到线程<code>Thread</code>，每当要并行处理一个事务就要创建一个线程，就要进行这些的工作：<br>1、创建线程并分配资源；<br>2、调度和执行线程；<br>3、结束线程并回收资源。<br>当一个进程里同时存在的线程数比CPU核心线程数量多的时候，其实超出的部分线程是无法同时执行的，也就是创建再多的线程也无法提高处理器效率。但是为了并行处理事务还是需要创建这些线程。<br>线程池<code>ThreadPool</code>的出现就是为了解决当这种情况出现时，可以用同一线程去并行处理不同事务而处理器无需浪费多余的性能和内存资源去做第一步和第三步。<br>而任务<code>Task</code>就是.Net对线程池的一种更人性化的封装，让我们可以更简单地并行处理事务。</p><ul><li><strong>声明和调用一个Task</strong><div class="code-wrapper"><pre><code class="hljs cs"> <span class="hljs-comment">// 1.Lambda表达式</span>Task task = <span class="hljs-keyword">new</span> Task(() =&gt; &#123;    Console.WriteLine(<span class="hljs-string">&quot;Hello&quot;</span>);&#125;); <span class="hljs-comment">// action</span>Task&lt;<span class="hljs-built_in">int</span>&gt; task = <span class="hljs-keyword">new</span> Task&lt;<span class="hljs-built_in">int</span>&gt;(() =&gt; &#123;    Console.WriteLine(<span class="hljs-string">&quot;Hello&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>.Length;&#125;); <span class="hljs-comment">// func</span>task.Start();<span class="hljs-comment">// 2.声明成一个函数（这种声明方式可以接受参数）</span><span class="hljs-function"><span class="hljs-keyword">static</span> Task&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">PrintText</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> text</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Task&lt;<span class="hljs-built_in">int</span>&gt;(() =&gt; &#123;        Console.WriteLine(text);        <span class="hljs-keyword">return</span> text.Length;    &#125;);&#125;PrintText(<span class="hljs-string">&quot;Hello&quot;</span>).Start();<span class="hljs-comment">// 3.直接创建并运行Task</span>Task&lt;<span class="hljs-built_in">int</span>&gt; task = Task.Run(() =&gt;&#123;    Console.WriteLine(<span class="hljs-string">&quot;Hello&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>.Length;&#125;);Console.WriteLine(task.Result); <span class="hljs-comment">// 获取返回值</span></code></pre></div></li><li><strong>通过几个简单例子初步理解Task的工作方式</strong><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">static</span> Task&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">PrintText</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> text</span>)</span><span class="hljs-function"></span>&#123;    Console.WriteLine(DateTime.Now.ToString(<span class="hljs-string">&quot;mm:ss:ffff&quot;</span>) + <span class="hljs-string">&quot; PrintText Started&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Task&lt;<span class="hljs-built_in">int</span>&gt;(() =&gt; &#123;        Thread.Sleep(<span class="hljs-number">500</span>);        Console.WriteLine(DateTime.Now.ToString(<span class="hljs-string">&quot;mm:ss:ffff&quot;</span>) + <span class="hljs-string">&quot; &quot;</span> + text);        <span class="hljs-keyword">return</span> text.Length;    &#125;);&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><span class="hljs-function"></span>&#123;    Console.WriteLine(DateTime.Now.ToString(<span class="hljs-string">&quot;mm:ss:ffff&quot;</span>) + <span class="hljs-string">&quot; create task&quot;</span>);    Task task = PrintText(<span class="hljs-string">&quot;Hello&quot;</span>);    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> task status: <span class="hljs-subst">&#123;task.Status&#125;</span>&quot;</span>);    task.Start();    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> task status: <span class="hljs-subst">&#123;task.Status&#125;</span>&quot;</span>);    task.Wait();    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> task status: <span class="hljs-subst">&#123;task.Status&#125;</span>&quot;</span>);    Console.WriteLine(DateTime.Now.ToString(<span class="hljs-string">&quot;mm:ss:ffff&quot;</span>) + <span class="hljs-string">&quot; continue&quot;</span>);&#125;</code></pre></div>结果<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">23</span>:<span class="hljs-number">02</span>:<span class="hljs-number">7737</span> create task<span class="hljs-attribute">23</span>:<span class="hljs-number">02</span>:<span class="hljs-number">7767</span> PrintText Started<span class="hljs-attribute">23</span>:<span class="hljs-number">02</span>:<span class="hljs-number">7767</span> task status: Created<span class="hljs-attribute">23</span>:<span class="hljs-number">02</span>:<span class="hljs-number">7827</span> task status: WaitingToRun<span class="hljs-attribute">23</span>:<span class="hljs-number">03</span>:<span class="hljs-number">2837</span> Hello<span class="hljs-attribute">23</span>:<span class="hljs-number">03</span>:<span class="hljs-number">2837</span> task status: RanToCompletion<span class="hljs-attribute">23</span>:<span class="hljs-number">03</span>:<span class="hljs-number">2837</span> continue</code></pre></div>通过<code>task.Status</code>可以看出正常运行的任务有三种状态，分别是:<br>1、<code>Created</code>: 完成创建<br>2、<code>WaitingToRun</code>: 在任务队列中等待被执行<br>3、<code>RanToCompletion</code>: 执行完毕<br>现在，任务已经是和主线程并行执行了。接下来改一下Thread.Sleep(500)的位置再看看结果<div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">static</span> Task&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">PrintText</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> text</span>)</span><span class="hljs-function"></span>&#123;    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> ManagedThreadId: <span class="hljs-subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> PrintText Started&quot;</span>);    Thread.Sleep(<span class="hljs-number">500</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Task&lt;<span class="hljs-built_in">int</span>&gt;(() =&gt; &#123;        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> ManagedThreadId: <span class="hljs-subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> <span class="hljs-subst">&#123;text&#125;</span>&quot;</span>);        <span class="hljs-keyword">return</span> text.Length;    &#125;);&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><span class="hljs-function"></span>&#123;    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> ManagedThreadId: <span class="hljs-subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);    Console.WriteLine(DateTime.Now.ToString(<span class="hljs-string">&quot;mm:ss:ffff&quot;</span>) + <span class="hljs-string">&quot; create task&quot;</span>);    Task task = PrintText(<span class="hljs-string">&quot;Hello&quot;</span>);    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> task status: <span class="hljs-subst">&#123;task.Status&#125;</span>&quot;</span>);    task.Start();    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> task status: <span class="hljs-subst">&#123;task.Status&#125;</span>&quot;</span>);    task.Wait();    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> task status: <span class="hljs-subst">&#123;task.Status&#125;</span>&quot;</span>);    Console.WriteLine(DateTime.Now.ToString(<span class="hljs-string">&quot;mm:ss:ffff&quot;</span>) + <span class="hljs-string">&quot; continue&quot;</span>);&#125;</code></pre></div>结果<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">13</span>:<span class="hljs-number">39</span>:<span class="hljs-number">9913</span> ManagedThreadId: <span class="hljs-number">1</span><span class="hljs-attribute">13</span>:<span class="hljs-number">39</span>:<span class="hljs-number">9933</span> create task<span class="hljs-attribute">13</span>:<span class="hljs-number">39</span>:<span class="hljs-number">9943</span> ManagedThreadId: <span class="hljs-number">1</span><span class="hljs-attribute">13</span>:<span class="hljs-number">39</span>:<span class="hljs-number">9943</span> PrintText Started<span class="hljs-attribute">13</span>:<span class="hljs-number">40</span>:<span class="hljs-number">4957</span> task status: Created<span class="hljs-attribute">13</span>:<span class="hljs-number">40</span>:<span class="hljs-number">5047</span> task status: WaitingToRun<span class="hljs-attribute">13</span>:<span class="hljs-number">40</span>:<span class="hljs-number">5047</span> ManagedThreadId: <span class="hljs-number">3</span><span class="hljs-attribute">13</span>:<span class="hljs-number">40</span>:<span class="hljs-number">5047</span> Hello<span class="hljs-attribute">13</span>:<span class="hljs-number">40</span>:<span class="hljs-number">5057</span> task status: RanToCompletion<span class="hljs-attribute">13</span>:<span class="hljs-number">40</span>:<span class="hljs-number">5057</span> continue</code></pre></div>可以看出来，<code>PrintText(&quot;Hello&quot;).Start()</code>执行的是<code>return</code>的<code>Task</code>里面的内容，对<code>PrintText</code>函数里的代码跟普通函数一样，由主线程执行。那如果我们希望能够异步执行我们希望异步执行的代码该怎么做？这时候就要引入两个关键字<code>async</code>和<code>await</code></li></ul><h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h2><p>async和await关键字的引入大大增加了异步编程的灵活性。</p><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">PrintText</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> text</span>)</span><span class="hljs-function"></span>&#123;    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> PrintText Started&quot;</span>);    Thread.Sleep(<span class="hljs-number">300</span>);    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> had slept 300 ms&quot;</span>);    <span class="hljs-keyword">await</span> Task.Run(() =&gt; &#123;        Thread.Sleep(<span class="hljs-number">500</span>);        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> <span class="hljs-subst">&#123;text&#125;</span>&quot;</span>);    &#125;);    <span class="hljs-keyword">return</span> text.Length;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><span class="hljs-function"></span>&#123;    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> create task&quot;</span>);    PrintText(<span class="hljs-string">&quot;Hello&quot;</span>);    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> continue&quot;</span>);&#125;</code></pre></div><p>结果</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">54</span>:<span class="hljs-number">27</span>:<span class="hljs-number">0703</span> create task<span class="hljs-attribute">54</span>:<span class="hljs-number">27</span>:<span class="hljs-number">0743</span> PrintText Started<span class="hljs-attribute">54</span>:<span class="hljs-number">27</span>:<span class="hljs-number">3753</span> had slept <span class="hljs-number">300</span> ms<span class="hljs-attribute">54</span>:<span class="hljs-number">27</span>:<span class="hljs-number">4003</span> continue<span class="hljs-attribute">54</span>:<span class="hljs-number">27</span>:<span class="hljs-number">9023</span> Hello</code></pre></div><p>我们用关键字<code>async</code>和<code>await</code>把<code>PrintText</code>函数改写成上面的样子，这个时候<code>PrintText</code>变成了一个任务函数。无需用<code>.Start()</code>就可以直接执行。<br>通过输出结果可以看到，对于没有加<code>await</code>前缀的代码行，实际还是由主线程执行，而<code>await Task.Run()</code>这一句则跟主线程并行执行。当我们想在任务函数里实现同步延迟，而又不希望阻塞主线程时，我们就可以用<code>await Task.Run(() =&gt; &#123; code &#125;);</code>去执行代码。<br>如果单纯想在任务函数内进行延迟而不影响主线程，可以用Task类提供的<code>Task.Delay(int millisecondsDelay)</code>，实质上返回的是一个由System.Threading.Timer实现的定时器任务。<code>await Task.Delay(500);</code>效果约等于<code>await Task.Run(() =&gt; Thread.Sleep(500));</code><br>同样地，如果希望在Main中阻塞执行任务函数，需要将其改成</p><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><span class="hljs-function"></span>&#123;    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> create task&quot;</span>);    <span class="hljs-keyword">await</span> PrintText(<span class="hljs-string">&quot;Hello&quot;</span>);   <span class="hljs-comment">// 在这里的效果相当于`PrintText(&quot;Hello&quot;).Wait();`，但本质却大有不同，这会在另一篇博文详细说</span>    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> continue&quot;</span>);&#125;</code></pre></div><p>由于带返回值的任务函数要在执行完整个任务函数后才能获取结果，所以还可以通过这种方式进行阻塞</p><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><span class="hljs-function"></span>&#123;    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> create task&quot;</span>);    Console.WriteLine(PrintText(<span class="hljs-string">&quot;Hello&quot;</span>).Result);    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> continue&quot;</span>);&#125;</code></pre></div><h2 id="Task的简单应用"><a href="#Task的简单应用" class="headerlink" title="Task的简单应用"></a>Task的简单应用</h2><p>假设一个场景，你要到奶茶店点一杯宇治抹茶，但是因为你接下来有其他事情要处理，所以你只能等待2分半钟，如果超过这个时间就取消订单。</p><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-title">Dictionary</span>&lt;<span class="hljs-title">string</span>, <span class="hljs-title">int</span>&gt; timeTable</span> = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;() &#123; &#123; <span class="hljs-string">&quot;宇治抹茶&quot;</span>, <span class="hljs-number">3</span> &#125;, &#123; <span class="hljs-string">&quot;珍珠奶茶&quot;</span>, <span class="hljs-number">2</span> &#125; &#125;;<span class="hljs-function"><span class="hljs-keyword">static</span> Task <span class="hljs-title">OrderMilkTea</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> tea, CancellationToken cancellationToken</span>)</span><span class="hljs-function"></span>&#123;    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> 下单&quot;</span>);    <span class="hljs-keyword">return</span> Task.Run(() =&gt; MakeTea(tea, cancellationToken));&#125;<span class="hljs-comment">// 等待制作奶茶</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeTea</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> tea, CancellationToken cancellationToken</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (cancellationToken.IsCancellationRequested)    &#123;        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> 开始制作前已取消订单&quot;</span>);        cancellationToken.ThrowIfCancellationRequested();    &#125;    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> 开始制作 <span class="hljs-subst">&#123;tea&#125;</span> -&gt; &quot;</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> time = <span class="hljs-number">1</span>; time &lt;= timeTable[tea]; time++) <span class="hljs-comment">// 模拟制作奶茶过程</span>    &#123;        Thread.Sleep(<span class="hljs-number">1000</span>);        <span class="hljs-keyword">if</span> (cancellationToken.IsCancellationRequested)            cancellationToken.ThrowIfCancellationRequested();        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> 目前用时 &quot;</span> + time + <span class="hljs-string">&quot; 分钟&quot;</span>);    &#125;    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> <span class="hljs-subst">&#123;tea&#125;</span> 已经做好&quot;</span>);&#125;<span class="hljs-comment">// 模拟手机计时</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">TikTok</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> milli</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">await</span> Task.Delay(milli);&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><span class="hljs-function"></span>&#123;    CancellationTokenSource cancelTokenSource = <span class="hljs-keyword">new</span> CancellationTokenSource();    Task task1 = OrderMilkTea(<span class="hljs-string">&quot;宇治抹茶&quot;</span>, cancelTokenSource.Token); <span class="hljs-comment">// 下单任务</span>    Task task2 = TikTok(<span class="hljs-number">2500</span>);  <span class="hljs-comment">// 计时任务</span>    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> 处理其他事情&quot;</span>);    Thread.Sleep(<span class="hljs-number">1000</span>);    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> 处理完毕&quot;</span>);    <span class="hljs-built_in">int</span> completedTask = Task.WaitAny(task1, task2) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 开始下单并等待</span>    <span class="hljs-keyword">if</span> (completedTask == <span class="hljs-number">2</span>)    &#123;        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> 奶茶做太久了，取消订单 -&gt; x&quot;</span>);        cancelTokenSource.Cancel();    &#125;    <span class="hljs-keyword">try</span>    &#123;        <span class="hljs-keyword">await</span> task1;    &#125;    catch (OperationCanceledException oce)    &#123;        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> 订单已取消&quot;</span>);    &#125;    <span class="hljs-keyword">finally</span>    &#123;        cancelTokenSource.Dispose();    &#125;&#125;</code></pre></div><p>结果</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">44</span>:<span class="hljs-number">31</span>:<span class="hljs-number">8562</span> 下单<span class="hljs-attribute">44</span>:<span class="hljs-number">31</span>:<span class="hljs-number">8722</span> 处理其他事情<span class="hljs-attribute">44</span>:<span class="hljs-number">31</span>:<span class="hljs-number">8728</span> 开始制作 宇治抹茶 -&gt;<span class="hljs-attribute">44</span>:<span class="hljs-number">32</span>:<span class="hljs-number">8728</span> 处理完毕<span class="hljs-attribute">44</span>:<span class="hljs-number">32</span>:<span class="hljs-number">8738</span> 目前用时 <span class="hljs-number">1</span> 分钟<span class="hljs-attribute">44</span>:<span class="hljs-number">33</span>:<span class="hljs-number">8757</span> 目前用时 <span class="hljs-number">2</span> 分钟<span class="hljs-attribute">44</span>:<span class="hljs-number">34</span>:<span class="hljs-number">3802</span> 奶茶做太久了，取消订单 -&gt; x<span class="hljs-attribute">44</span>:<span class="hljs-number">34</span>:<span class="hljs-number">8849</span> 订单已取消</code></pre></div><p>在这个例子里，我们新建了两个Task，task1代表制作奶茶，task2代表手机的计时。下单后，在等待制作奶茶的时候，我们可以处理我们想要处理的事情（在这个例子里处理了1分钟），当2分半的计时结束后，奶茶还没制作完成，于是我们取消了订单。</p><p>1、<code>Task.WaitAny(params Task[] tasks)</code>: 阻塞等待参数中最先完成的任务，返回最先完成的任务的下标（按参数从左到右的顺序）<br>2、<code>CancellationTokenSource</code>: 这个类的逻辑是非常简单的信号操作。通过<code>CancellationTokenSource.Cancel()</code>设置取消信号，在任务中检查<code>CancellationTokenSource.Token.IsCancellationRequested</code>的值，若为true，则通过<code>Token.ThrowIfCancellationRequested()</code>抛出异常打断任务。事实上，通过<code>throw new OperationCanceledException()</code>以及<code>OperationCanceledException()</code>的相关重载函数也能达到一样的效果。<br>3、<code>Task.Run(Action action, CancellationToken cancellationToken)</code>: 假设我们在去到奶茶店后临时改变计划而取消，也就是在<code>Task.WaitAny(task1, task2)</code>前就调用<code>cancelTokenSource.Cancel()</code>,那通过<code>Task.Run(Action action, CancellationToken cancellationToken)</code>可以在执行任务前就取消掉任务。本示例演示了通过<code>Task.Run(Action action)</code>并在任务开始时就检查信号达到类似的效果。</p><h2 id="Task的取消"><a href="#Task的取消" class="headerlink" title="Task的取消"></a>Task的取消</h2><h3 id="CancellationTokenSource"><a href="#CancellationTokenSource" class="headerlink" title="CancellationTokenSource"></a>CancellationTokenSource</h3><p>如上例子。</p><h3 id="Thread-Abort"><a href="#Thread-Abort" class="headerlink" title="Thread.Abort"></a>Thread.Abort</h3><p>上面“点奶茶”的例子通过调用<code>CancellationTokenSource.Cancel()</code>去取消任务时，并不是立刻就取消掉任务，而需要在<code>Thread.Sleep(1000)</code>（也就是制作一段时间）结束等待后才能结束。Task类本身并没有提供立即取消任务的机制，但如果我们想要“立刻”中止任务，有没有办法呢？下面利用<code>Thread.Abort</code>尝试一下。<br><font size=2 color=gray>下面的例子参考自<a href="https://stackoverflow.com/questions/4359910/is-it-possible-to-abort-a-task-like-aborting-a-thread-thread-abort-method">Is it possible to abort a Task like aborting a Thread (Thread.Abort method)?</a>上的回答</font></p><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-keyword">class</span> <span class="hljs-title">HardAborter</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> WasAborted &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-keyword">public</span> System.Threading.ThreadState? ThreadState =&gt; TaskThread?.ThreadState;    <span class="hljs-keyword">private</span> Thread TaskThread;    <span class="hljs-keyword">private</span> CancellationTokenSource Canceller &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-keyword">private</span> Task&lt;<span class="hljs-built_in">object</span>&gt; Worker &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params">Func&lt;<span class="hljs-built_in">object</span>&gt; DoFunc</span>)</span><span class="hljs-function"></span>    &#123;        WasAborted = <span class="hljs-literal">false</span>;        <span class="hljs-comment">// start a task with a means to do a hard abort (unsafe!)</span>        Canceller = <span class="hljs-keyword">new</span> CancellationTokenSource();        Worker = Task.Factory.StartNew(() =&gt;        &#123;            <span class="hljs-keyword">try</span>            &#123;                <span class="hljs-comment">// specify this thread&#x27;s Abort() as the cancel delegate</span>                <span class="hljs-keyword">using</span> (Canceller.Token.Register(Thread.CurrentThread.Abort))                &#123;                    TaskThread = Thread.CurrentThread;                    <span class="hljs-keyword">return</span> DoFunc();                &#125;            &#125;            catch (ThreadAbortException)            &#123;                WasAborted = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;, Canceller.Token);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Abort</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>    &#123;        Canceller.Cancel();    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><span class="hljs-function"></span>&#123;    HardAborter hardAborter = <span class="hljs-keyword">new</span> HardAborter();    hardAborter.Start(() =&gt;    &#123;        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> task started&quot;</span>);        Thread.Sleep(<span class="hljs-number">2000</span>);        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> task finished&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;);    Thread.Sleep(<span class="hljs-number">50</span>);   <span class="hljs-comment">// 稍微等待一段时间让任务开始执行</span>    hardAborter.Abort();    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> abort task, task state: <span class="hljs-subst">&#123;hardAborter.ThreadState&#125;</span>&quot;</span>);    <span class="hljs-keyword">while</span> (!hardAborter.WasAborted) &#123; Thread.CurrentThread.Join(<span class="hljs-number">0</span>); &#125;    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now:mm:ss:ffff&#125;</span> task aborted&quot;</span>);&#125;</code></pre></div><p>结果</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">21</span>:<span class="hljs-number">16</span>:<span class="hljs-number">2408</span> task started<span class="hljs-attribute">21</span>:<span class="hljs-number">16</span>:<span class="hljs-number">3018</span> abort task, task state: Background, WaitSleepJoin, AbortRequested<span class="hljs-attribute">21</span>:<span class="hljs-number">16</span>:<span class="hljs-number">3028</span> task aborted</code></pre></div><p>通过<code>Canceller.Token.Register(Thread.CurrentThread.Abort)</code>在任务创建时，把任务所在线程的<code>About()</code>注册为<code>Token.Cancel()</code>的action，也就是当执行Token.Cancel()时会把任务所在线程Abort掉。</p><p>然而，这其实存在三个问题。第一，虽然看起来任务在调用<code>hardAborter.Abort()</code>时马上就被中止了，但事实上，任务所在的线程还在运行。因为如果一个线程正在进行IO的调用或者等待，哪怕通过<code>Thread.Abort</code>去中止线程，线程也无法立刻中止，而需要等IO调用返回或者等待结束才能中止。第二，这种“不透明”的操作对于开发者都是不应该的。第三，由于线程池里的线程经常负责多个任务的执行，如果为了中止一个任务而中止了所在的线程，很可能造成其他问题（未验证）。</p><p><strong>但是</strong>，假设我们开启的一个线程调用了一个第三方的方法，而这个方法由于某种原因超时工作，而这个第三方库有没有提供中止的方法（当然这是不应该的），我们必需主动去中止这个线程。这个时候，利用<code>Thread.Abort</code>去中止线程是必要的。</p><p><strong>但是</strong>，从ASP.NET Core开始，<code>Thread.Abort</code>就被弃用了，如果在之后的版本中尝试调用会抛出<em>PlatformNotSupportedException</em>、<em>SecurityException</em>、<em>ThreadStateException</em>等异常，那怎么去解决上述这种特殊情况呢？</p><h3 id="kernel32-API"><a href="#kernel32-API" class="headerlink" title="kernel32 API"></a>kernel32 API</h3><p>这里的例子直接使用 <a href="https://stackoverflow.com/a/55709530/9897639">How to abort a Task like aborting a Thread</a> 答案提供的扩展方法。</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">new</span> Action(PrintElapsed).RunWithAbort(<span class="hljs-number">5000</span>);<span class="hljs-comment">// 线程会如期在5000毫秒左右中止</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintElapsed</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>    &#123;        Stopwatch sw = <span class="hljs-keyword">new</span> Stopwatch();        sw.Start();        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)        &#123;            Console.WriteLine(sw.ElapsedMilliseconds);        &#125;    &#125;&#125;<span class="hljs-comment">// 调用API的方法</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestExtensions</span>&#123;    [<span class="hljs-meta">DllImport(<span class="hljs-meta-string">&quot;kernel32&quot;</span>)</span>]    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">TerminateThread</span>(<span class="hljs-params">IntPtr hThread, <span class="hljs-built_in">int</span> dwExitCode</span>)</span>;    [<span class="hljs-meta">DllImport(<span class="hljs-meta-string">&quot;kernel32&quot;</span>)</span>]    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> IntPtr <span class="hljs-title">CreateThread</span>(<span class="hljs-params">IntPtr lpThreadAttributes, IntPtr dwStackSize, Delegate lpStartAddress, IntPtr lpParameter, <span class="hljs-built_in">int</span> dwCreationFlags, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> lpThreadId</span>)</span>;    [<span class="hljs-meta">DllImport(<span class="hljs-meta-string">&quot;kernel32&quot;</span>)</span>]    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">CloseHandle</span>(<span class="hljs-params">IntPtr hObject</span>)</span>;    [<span class="hljs-meta">DllImport(<span class="hljs-meta-string">&quot;kernel32&quot;</span>)</span>]    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">WaitForSingleObject</span>(<span class="hljs-params">IntPtr hHandle, <span class="hljs-built_in">int</span> dwMilliseconds</span>)</span>;        <span class="hljs-comment">// returns true if the call went to completion successfully, false otherwise</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">RunWithAbort</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Action action, <span class="hljs-built_in">int</span> milliseconds</span>)</span> =&gt; RunWithAbort(action, <span class="hljs-keyword">new</span> TimeSpan(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, milliseconds));    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">RunWithAbort</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Action action, TimeSpan delay</span>)</span><span class="hljs-function"></span>    &#123;        <span class="hljs-keyword">if</span> (action == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(action));        <span class="hljs-keyword">var</span> source = <span class="hljs-keyword">new</span> CancellationTokenSource(delay);        <span class="hljs-keyword">var</span> success = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">var</span> handle = IntPtr.Zero;        <span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">new</span> Action(() =&gt;        &#123;            <span class="hljs-keyword">using</span> (source.Token.Register(() =&gt; TerminateThread(handle, <span class="hljs-number">0</span>)))            &#123;                action();                success = <span class="hljs-literal">true</span>;            &#125;        &#125;);        handle = CreateThread(IntPtr.Zero, IntPtr.Zero, fn, IntPtr.Zero, <span class="hljs-number">0</span>, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> id);        WaitForSingleObject(handle, <span class="hljs-number">100</span> + (<span class="hljs-built_in">int</span>)delay.TotalMilliseconds);        CloseHandle(handle);        <span class="hljs-keyword">return</span> success;    &#125;    <span class="hljs-comment">// returns what&#x27;s the function should return if the call went to completion successfully, default(T) otherwise</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">RunWithAbort</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> Func&lt;T&gt; func, <span class="hljs-built_in">int</span> milliseconds</span>)</span> =&gt; RunWithAbort(func, <span class="hljs-keyword">new</span> TimeSpan(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, milliseconds));    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">RunWithAbort</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> Func&lt;T&gt; func, TimeSpan delay</span>)</span><span class="hljs-function"></span>    &#123;        <span class="hljs-keyword">if</span> (func == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(func));        <span class="hljs-keyword">var</span> source = <span class="hljs-keyword">new</span> CancellationTokenSource(delay);        <span class="hljs-keyword">var</span> item = <span class="hljs-literal">default</span>(T);        <span class="hljs-keyword">var</span> handle = IntPtr.Zero;        <span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">new</span> Action(() =&gt;        &#123;            <span class="hljs-keyword">using</span> (source.Token.Register(() =&gt; TerminateThread(handle, <span class="hljs-number">0</span>)))            &#123;                item = func();            &#125;        &#125;);        handle = CreateThread(IntPtr.Zero, IntPtr.Zero, fn, IntPtr.Zero, <span class="hljs-number">0</span>, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> id);        WaitForSingleObject(handle, <span class="hljs-number">100</span> + (<span class="hljs-built_in">int</span>)delay.TotalMilliseconds);        CloseHandle(handle);        <span class="hljs-keyword">return</span> item;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>.Net</category>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>异步编程</tag>
      
      <tag>Task</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo不识别标签特殊符号的问题和解决</title>
    <link href="/2020/04/22/Hexo%E4%B8%8D%E8%AF%86%E5%88%AB%E6%A0%87%E7%AD%BE%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3/"/>
    <url>/2020/04/22/Hexo%E4%B8%8D%E8%AF%86%E5%88%AB%E6%A0%87%E7%AD%BE%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>用Hexo在Github和Gitee上部署站点之后，刚开始创建了几个md文件，里面有个tag-<code>c#</code>，后来改成<code>C#</code>（小写换成大写），出现了相关的标签页不能访问的问题。测试了很久发现主要存在几个问题（或者说是现象）。<br>另外，当同时存在如<code>C</code>、<code>C++</code>、<code>C#</code>这三个标签时，在生成网站的时候，三个标签实际上会被认作同一个标签也就是<code>C</code>。</p><a id="more"></a><style>table { margin-left: 2em; }</style><h3 id="问题和现象"><a href="#问题和现象" class="headerlink" title="问题和现象"></a>问题和现象</h3><p><em>索引即目录</em></p><ul><li><p><strong>Git系统不区分索引的大小写</strong><br>一旦用Git命令创建了一个索引（需要索引下有文件才会创建），之后哪怕在本地改变了索引当中英文字母的大小写，当<code>commit</code>或者<code>push</code>的时候Git也不会对库里面的索引进行更改。而命令<code>git config core.ignorecase false</code>禁用忽略大小写也只是不忽略文件名的大小写，对索引并不有效。</p></li><li><p><strong>在Git系统改变文件名的大小写后不删除旧文件</strong><br>另一个奇怪的现在是当执行了命令<code>git config core.ignorecase false</code>后，如果修改了文件名的大小写后执行<code>commit</code>或者<code>push</code>后，Git确实产生了以新的大小写命名的文件，但旧文件却仍然存在，这是一个非常奇怪的现象。</p></li><li><p><strong>文件系统普遍不区分索引的大小写</strong><br>当发现Git是不区分索引的大小写后，我又试了win10的文件系统，也是存在同样的现象，当创建一个名为&quot;c&quot;的文件夹后，如果想在同目录下创建一个名&quot;C&quot;的文件夹会被提示已存在相同目录。</p></li><li><p><strong>Github、Gitee提供的Web服务区分大小写</strong><br>了解到文件系统普遍不区分索引的大小写后，我就不怪Git了，而是奇怪的是像Windows的IIS或者Apache也都是不区分网址大小写的，平常浏览网页也没未遇到因为网址的大小写不同而不能访问的情况。Github和Gitee提供的Web服务真有点神奇，不知道什么原理。</p></li><li><p><strong>Hexo不能识别标签的特殊符号</strong><br>Hexo创建<code>tags</code>里面的标签的时候是不能识别一些符号的，如<code>.</code>、<code>#</code>，所以如果想同时创建一个<code>C</code>标签和<code>C#</code>标签是不行的，要用<code>CSharp</code>、<code>DotNet</code>之类的写法。<br>实际上，经过测试，Github、Gitee的文件夹名都支持这类符号，如<code>.Net</code>、<code>C#</code>，而在用网址去索引的时候可以用转义字符，如<code>C#</code>可以用<code>C%23</code>去索引资源，而<code>.Net</code>甚至不用去转义。因此，这应该算是Hexo的一个小缺陷了。</p></li></ul><p>&emsp;&emsp;<em>URL中特殊字符转义编码</em></p><table><thead><tr><th align="center">!</th><th align="center">*</th><th align="center">“</th><th align="center">‘</th><th align="center">(</th><th align="center">)</th><th align="center">;</th><th align="center">:</th><th align="center">@</th><th align="center">&amp;</th></tr></thead><tbody><tr><td align="center">%21</td><td align="center">%2A</td><td align="center">%22</td><td align="center">%27</td><td align="center">%28</td><td align="center">%29</td><td align="center">%3B</td><td align="center">%3A</td><td align="center">%40</td><td align="center">%26</td></tr></tbody></table><table><thead><tr><th align="center">=</th><th align="center">+</th><th align="center">$</th><th align="center">,</th><th align="center">/</th><th align="center">?</th><th align="center">%</th><th align="center">#</th><th align="center">[</th><th align="center">]</th></tr></thead><tbody><tr><td align="center">%3D</td><td align="center">%2B</td><td align="center">%24</td><td align="center">%2C</td><td align="center">%2F</td><td align="center">%3F</td><td align="center">%25</td><td align="center">%23</td><td align="center">%5B</td><td align="center">%5D</td></tr></tbody></table><p>&emsp;&emsp;<em>关于特殊字符的转义可以参照 - <a href="https://blog.csdn.net/p312011150/article/details/78928003">网址URL中特殊字符转义编码</a></em></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>对于字母大小写问题也不是什么大问题，只要不在Github、Gitee上部署站点或者修改目录大小写的时候删除再重新创建（虽然Gitee可以直接在网页上修改目录名，但本地的也需要改，否则再提交又会恢复之前的文件夹名）就没问题了，毕竟只改目录名的大小写也不是经常会碰到的事情。</p><p>而Hexo生成的标签索引忽略标点符号和特殊符号这确实是个bug，譬如如果要用到<code>C</code>、<code>C++</code>、<code>C#</code>这三个标签就只能改用<code>C</code>、<code>Cpp</code>、<code>CSharp</code>之类的标签，因为前者都是在<code>tags</code>目录下创建同样的目录<code>C</code>，如果Hexo项目组能解决这个问题就好了。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>后来无意中找到原来HTML对特殊字符有统一的编码，于是试着在tags用统一编码代替标点或特殊字符，问题解决了！生成标签的规则是将转义字符用<code>-</code>加上转义字符<code>&amp;#</code>后的数字，如md文件下的标签<code>C&amp;#35;</code>将生成标签目录<code>C-35</code>。虽然tags目录下的对应标签目录名还是不能以<code>.</code>、<code>#</code>之类命名，而是以字符对应的编码中的数字代替，但大致上解决了这个问题。</p><p>&emsp;&emsp;<em>HTML中一些特殊字符的编码 参考<a href="https://www.dazhuanlan.com/2020/01/04/5e10105eba77e/">Hexo Markdown 特殊字符转义</a></em></p><table><thead><tr><th align="center">!</th><th align="center">”</th><th align="center">#</th><th align="center">$</th><th align="center">%</th><th align="center">&amp;</th><th align="center">‘</th><th align="center">(</th><th align="center">)</th><th align="center">*</th></tr></thead><tbody><tr><td align="center">&amp;#33;</td><td align="center">&amp;#34;</td><td align="center">&amp;#35;</td><td align="center">&amp;#36;</td><td align="center">&amp;#37;</td><td align="center">&amp;#38;</td><td align="center">&amp;#39;</td><td align="center">&amp;#40;</td><td align="center">&amp;#41;</td><td align="center">&amp;#42;</td></tr></tbody></table><table><thead><tr><th align="center">+</th><th align="center">&lt;</th><th align="center">=</th><th align="center">-</th><th align="center">&gt;</th><th align="center">?</th><th align="center">@</th><th align="center">[</th><th align="center">\</th><th align="center">]</th></tr></thead><tbody><tr><td align="center">&amp;#43;</td><td align="center">&amp;#60;</td><td align="center">&amp;#61;</td><td align="center">&amp;#45;</td><td align="center">&amp;#62;</td><td align="center">&amp;#63;</td><td align="center">&amp;#64;</td><td align="center">&amp;#91;</td><td align="center">&amp;#92;</td><td align="center">&amp;#93;</td></tr></tbody></table><table><thead><tr><th align="center">{</th><th align="center">|</th><th align="center">}</th></tr></thead><tbody><tr><td align="center">&amp;#123;</td><td align="center">&amp;#124;</td><td align="center">&amp;#125;</td></tr></tbody></table><p>还有其他的特殊字符的编码可参照 - <a href="https://blog.csdn.net/cy_baicai/article/details/82897724">特殊符号 UNICODE编码</a><br>也可以直接输入特殊字符获取它的HTML编码 - <a href="https://www.css-js.com/tools/unicode.html">Unicode 编码&amp;解码</a></p>]]></content>
    
    
    <categories>
      
      <category>日常吐槽</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chapter 3 - Objects and Types</title>
    <link href="/2020/04/21/Objects-and-Types/"/>
    <url>/2020/04/21/Objects-and-Types/</url>
    
    <content type="html"><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>名词：类<code>Class</code>、域<code>Field</code>、属性<code>Property</code>、方法<code>Method</code></p><h3 id="域、属性、方法"><a href="#域、属性、方法" class="headerlink" title="域、属性、方法"></a>域、属性、方法</h3><p>域是类拥有的变量，属性本质上是方法，只是表示上和用起来很像变量所以称作属性。</p><p><strong><font size=4>下面是一些初始化属性的简化写法</font></strong></p><ul><li><strong>表达式属性<code>Expression-Bodied Property</code></strong><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> firstName, <span class="hljs-built_in">string</span> lastName</span>)</span><span class="hljs-function"></span>    &#123;        FirstName = firstName;        LastName = lastName;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName &#123; <span class="hljs-keyword">get</span>; &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName &#123; <span class="hljs-keyword">get</span>; &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FullName =&gt; <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;FirstName&#125;</span> <span class="hljs-subst">&#123;LastName&#125;</span>&quot;</span>;    <span class="hljs-comment">// 利用这个特性还可以用变量初始化&quot;域&quot;</span>&#125;</code></pre></div></li><li><strong>自实现属性<code>Auto-Implemented Properties</code></strong><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; = <span class="hljs-number">42</span>;  <span class="hljs-comment">// get set 自动实现了对应方法，并完成初始化</span></code></pre></div></li><li><strong>可在表达式属性前添加修饰符<code>Access Modifiers for Properties</code></strong><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name&#123;    <span class="hljs-keyword">get</span> =&gt; _name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span> =&gt; _name = <span class="hljs-keyword">value</span>;&#125;</code></pre></div></li><li><strong>自实现只读属性<code>Auto-Implemented Read-Only Properties</code></strong><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Id &#123; <span class="hljs-keyword">get</span>; &#125; = Guid.NewGuid().ToString();</code></pre></div></li><li><strong>表达式方法<code>Expression-Bodied Methods</code></strong><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsSquare</span>(<span class="hljs-params">Rectangle rect</span>)</span> =&gt; rect.Height == rect.Width;</code></pre></div></li><li><strong>命名参数<code>Named Arguments</code></strong><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MoveAndResize</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y, <span class="hljs-built_in">int</span> width, intheight</span>)</span><span class="hljs-function"><span class="hljs-comment">// 为了更清晰表示各个参数的属性，传递参数时可以给参数起名</span></span><span class="hljs-function">r.<span class="hljs-title">MoveAndResize</span>(<span class="hljs-params">x: <span class="hljs-number">30</span>, y: <span class="hljs-number">40</span>, width: <span class="hljs-number">20</span>, height: <span class="hljs-number">40</span></span>)</span>;</code></pre></div></li><li><strong>构造函数调用构造函数（包括调用基类构造函数）</strong><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> _description;    <span class="hljs-keyword">private</span> uint _nWheels;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> description, uint nWheels</span>)</span><span class="hljs-function"></span>    &#123;        _description = description;        _nWheels = nWheels;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> description</span>): <span class="hljs-title">this</span>(<span class="hljs-params">description, <span class="hljs-number">4</span></span>)</span><span class="hljs-function"></span>    &#123;    &#125;&#125;</code></pre></div></li><li><strong>静态构造函数<code>Static Constructors</code></strong><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GetStaticVariable</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> Name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><span class="hljs-function"></span>    &#123;        Name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">GetStaticVariable</span>(<span class="hljs-params"></span>) </span><span class="hljs-function"></span>    &#123;        Name = <span class="hljs-string">&quot;小明&quot;</span>;    &#125;&#125;<span class="hljs-comment">// 直接调用而不用先Init</span><span class="hljs-built_in">string</span> name = GetStaticVariable.Name;</code></pre></div>使用静态构造函数而不是另外声明一个Init函数可以避免有时因为忘记调用初始化函数而导致出错。</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>名词：结构<code>Struct</code>、引用类型<code>Reference Type</code>、值类型<code>Value Type</code>、栈<code>Stack</code>、堆<code>Leap</code>、内联<code>Inline</code></p><p>1、struct属于值类型。<br>struct跟基本类型int、bool、type等一样，存储在栈或者inline(当在类中被声明时，存储在堆)，区别于存储在堆中的属于引用类型的class。作为参数传递时，也是跟其他的值类型一样是按值传递，也可以加上<code>ref</code>传递引用。<br>由于是值类型，所以struct在创建、使用和回收时都会比class占用更少的性能（至于少多少就被研究过了）。</p><p>2、struct不能被继承，自然也不支持多态，但可实现接口。</p><p>3、struct不能声明无参数构造函数；struct的构造函数必需初始化所有字段或属性，否则报错。隐式构造函数会将所有数据类型初始化为0（bool初始化为false），其他类型初始化为null。</p><details><summary>示例</summary><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Product</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Price;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Example &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Length;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Width;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> YesOrNo;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span> Byte;    <span class="hljs-keyword">public</span> Product Product;&#125;Example dimension;<span class="hljs-comment">/*</span><span class="hljs-comment">Length = 0;</span><span class="hljs-comment">Width = 0;</span><span class="hljs-comment">Name = null;</span><span class="hljs-comment">YesOrNo = false;</span><span class="hljs-comment">Byte = 0;</span><span class="hljs-comment">Product = null;</span><span class="hljs-comment">*/</span></code></pre></div></details>]]></content>
    
    
    <categories>
      
      <category>.Net</category>
      
      <category>C# 7 and .NET Core 2.0 - 学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>.Net Core</tag>
      
      <tag>C# 7.0</tag>
      
      <tag>.Net Core 2.0</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chapter 2 - Core C#</title>
    <link href="/2020/04/20/Core-CSharp/"/>
    <url>/2020/04/20/Core-CSharp/</url>
    
    <content type="html"><![CDATA[<p>这章没有多少值得记录的知识点，而预处理指令<code>PREPROCESSOR DIRECTIVES</code>暂时还没有应用到的场景，留待以后有机会再细看</p><p>名词：获取对象的类型<code>Type GetType()</code></p><h3 id="获取对象的类型"><a href="#获取对象的类型" class="headerlink" title="获取对象的类型"></a>获取对象的类型</h3><details><summary>示例</summary><div class="code-wrapper"><pre><code class="hljs cs"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Bugs Bunny&quot;</span>;<span class="hljs-keyword">var</span> age = <span class="hljs-number">25</span>;<span class="hljs-keyword">var</span> isRabbit = <span class="hljs-literal">true</span>;Type nameType = name.GetType();Type ageType = age.GetType();Type isRabbitType = isRabbit.GetType();Console.WriteLine(<span class="hljs-string">$&quot;name is of type <span class="hljs-subst">&#123;nameType&#125;</span>&quot;</span>);Console.WriteLine(<span class="hljs-string">$&quot;age is of type <span class="hljs-subst">&#123;ageType&#125;</span>&quot;</span>);Console.WriteLine(<span class="hljs-string">$&quot;isRabbit is of type <span class="hljs-subst">&#123;isRabbitType&#125;</span>&quot;</span>);</code></pre></div><p>输出</p><div class="code-wrapper"><pre><code class="hljs cs">name <span class="hljs-keyword">is</span> of type System.Stringage <span class="hljs-keyword">is</span> of type System.Int32isRabbit <span class="hljs-keyword">is</span> of type System.Boolean</code></pre></div></details>]]></content>
    
    
    <categories>
      
      <category>.Net</category>
      
      <category>C# 7 and .NET Core 2.0 - 学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>.Net Core</tag>
      
      <tag>C# 7.0</tag>
      
      <tag>.Net Core 2.0</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
